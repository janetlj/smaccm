/*
 * generated by Xtext
 */
package com.rockwellcollins.atc.agree.validation;

import static com.rockwellcollins.atc.agree.validation.AgreeType.BOOL;
import static com.rockwellcollins.atc.agree.validation.AgreeType.ERROR;
import static com.rockwellcollins.atc.agree.validation.AgreeType.INT;
import static com.rockwellcollins.atc.agree.validation.AgreeType.REAL;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.osate.aadl2.Aadl2Package;
import org.osate.aadl2.AadlBoolean;
import org.osate.aadl2.AadlInteger;
import org.osate.aadl2.AadlPackage;
import org.osate.aadl2.AadlReal;
import org.osate.aadl2.AadlString;
import org.osate.aadl2.AnnexLibrary;
import org.osate.aadl2.AnnexSubclause;
import org.osate.aadl2.Classifier;
import org.osate.aadl2.ClassifierType;
import org.osate.aadl2.ComponentClassifier;
import org.osate.aadl2.ComponentImplementation;
import org.osate.aadl2.ComponentType;
import org.osate.aadl2.Connection;
import org.osate.aadl2.DataAccess;
import org.osate.aadl2.DataImplementation;
import org.osate.aadl2.DataPort;
import org.osate.aadl2.DataSubcomponent;
import org.osate.aadl2.DataSubcomponentType;
import org.osate.aadl2.DataType;
import org.osate.aadl2.DirectionType;
import org.osate.aadl2.EnumerationType;
import org.osate.aadl2.EventDataPort;
import org.osate.aadl2.EventPort;
import org.osate.aadl2.Feature;
import org.osate.aadl2.FeatureGroup;
import org.osate.aadl2.FeatureGroupType;
import org.osate.aadl2.ModelUnit;
import org.osate.aadl2.NamedElement;
import org.osate.aadl2.Port;
import org.osate.aadl2.Property;
import org.osate.aadl2.PropertyConstant;
import org.osate.aadl2.PropertyType;
import org.osate.aadl2.Subcomponent;
import org.osate.aadl2.impl.SubcomponentImpl;
import org.osate.annexsupport.AnnexUtil;

import com.google.common.collect.HashMultimap;
import com.rockwellcollins.atc.agree.AgreeAADLEnumerationUtils;
import com.rockwellcollins.atc.agree.agree.AADLEnumerator;
import com.rockwellcollins.atc.agree.agree.AgreeContract;
import com.rockwellcollins.atc.agree.agree.AgreeContractLibrary;
import com.rockwellcollins.atc.agree.agree.AgreeContractSubclause;
import com.rockwellcollins.atc.agree.agree.AgreePackage;
import com.rockwellcollins.atc.agree.agree.AgreeSubclause;
import com.rockwellcollins.atc.agree.agree.Arg;
import com.rockwellcollins.atc.agree.agree.AssertStatement;
import com.rockwellcollins.atc.agree.agree.AssignStatement;
import com.rockwellcollins.atc.agree.agree.AssumeStatement;
import com.rockwellcollins.atc.agree.agree.AsynchStatement;
import com.rockwellcollins.atc.agree.agree.BinaryExpr;
import com.rockwellcollins.atc.agree.agree.BoolLitExpr;
import com.rockwellcollins.atc.agree.agree.CalenStatement;
import com.rockwellcollins.atc.agree.agree.CallDef;
import com.rockwellcollins.atc.agree.agree.ConnectionStatement;
import com.rockwellcollins.atc.agree.agree.ConstStatement;
import com.rockwellcollins.atc.agree.agree.EnumStatement;
import com.rockwellcollins.atc.agree.agree.EqStatement;
import com.rockwellcollins.atc.agree.agree.EventExpr;
import com.rockwellcollins.atc.agree.agree.Expr;
import com.rockwellcollins.atc.agree.agree.FloorCast;
import com.rockwellcollins.atc.agree.agree.FnCallExpr;
import com.rockwellcollins.atc.agree.agree.FnDefExpr;
import com.rockwellcollins.atc.agree.agree.GetPropertyExpr;
import com.rockwellcollins.atc.agree.agree.GuaranteeStatement;
import com.rockwellcollins.atc.agree.agree.IfThenElseExpr;
import com.rockwellcollins.atc.agree.agree.InitialStatement;
import com.rockwellcollins.atc.agree.agree.InputStatement;
import com.rockwellcollins.atc.agree.agree.IntLitExpr;
import com.rockwellcollins.atc.agree.agree.LatchedExpr;
import com.rockwellcollins.atc.agree.agree.LatchedStatement;
import com.rockwellcollins.atc.agree.agree.LemmaStatement;
import com.rockwellcollins.atc.agree.agree.LibraryFnDefExpr;
import com.rockwellcollins.atc.agree.agree.LiftStatement;
import com.rockwellcollins.atc.agree.agree.LinearizationDefExpr;
import com.rockwellcollins.atc.agree.agree.LinearizationInterval;
import com.rockwellcollins.atc.agree.agree.MNSynchStatement;
import com.rockwellcollins.atc.agree.agree.NamedID;
import com.rockwellcollins.atc.agree.agree.NamedSpecStatement;
import com.rockwellcollins.atc.agree.agree.NestedDotID;
import com.rockwellcollins.atc.agree.agree.NodeBodyExpr;
import com.rockwellcollins.atc.agree.agree.NodeDefExpr;
import com.rockwellcollins.atc.agree.agree.NodeEq;
import com.rockwellcollins.atc.agree.agree.NodeLemma;
import com.rockwellcollins.atc.agree.agree.NodeStmt;
import com.rockwellcollins.atc.agree.agree.OrderStatement;
import com.rockwellcollins.atc.agree.agree.PeriodicStatement;
import com.rockwellcollins.atc.agree.agree.PreExpr;
import com.rockwellcollins.atc.agree.agree.PrevExpr;
import com.rockwellcollins.atc.agree.agree.PrimType;
import com.rockwellcollins.atc.agree.agree.PropertyStatement;
import com.rockwellcollins.atc.agree.agree.RealCast;
import com.rockwellcollins.atc.agree.agree.RealLitExpr;
import com.rockwellcollins.atc.agree.agree.RecordDefExpr;
import com.rockwellcollins.atc.agree.agree.RecordExpr;
import com.rockwellcollins.atc.agree.agree.RecordType;
import com.rockwellcollins.atc.agree.agree.RecordUpdateExpr;
import com.rockwellcollins.atc.agree.agree.SpecStatement;
import com.rockwellcollins.atc.agree.agree.SporadicStatement;
import com.rockwellcollins.atc.agree.agree.SynchStatement;
import com.rockwellcollins.atc.agree.agree.ThisExpr;
import com.rockwellcollins.atc.agree.agree.TimeExpr;
import com.rockwellcollins.atc.agree.agree.TimeFallExpr;
import com.rockwellcollins.atc.agree.agree.TimeInterval;
import com.rockwellcollins.atc.agree.agree.TimeOfExpr;
import com.rockwellcollins.atc.agree.agree.TimeRiseExpr;
import com.rockwellcollins.atc.agree.agree.Type;
import com.rockwellcollins.atc.agree.agree.UnaryExpr;
import com.rockwellcollins.atc.agree.agree.WhenHoldsStatement;
import com.rockwellcollins.atc.agree.agree.WhenOccursStatment;
import com.rockwellcollins.atc.agree.agree.WheneverBecomesTrueStatement;
import com.rockwellcollins.atc.agree.agree.WheneverHoldsStatement;
import com.rockwellcollins.atc.agree.agree.WheneverImpliesStatement;
import com.rockwellcollins.atc.agree.agree.WheneverOccursStatement;
import com.rockwellcollins.atc.agree.visitors.ExprCycleVisitor;

/**
 * Custom validation rules.
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class AgreeJavaValidator extends AbstractAgreeJavaValidator {
	private final Set<CallDef> checkedRecCalls = new HashSet<>();
	private final Map<String, Map<String, NamedID>> enumSets = new HashMap<>();

	@Override
	protected boolean isResponsible(Map<Object, Object> context, EObject eObject) {
		return (eObject.eClass().getEPackage() == AgreePackage.eINSTANCE) || eObject instanceof AadlPackage;
	}

//	@Inject
//	IResourceDescriptions resourceDescriptions;
//
//	@Check(CheckType.FAST)
//	public void checkAADL2Package(AadlPackage pack){
//		Resource resource = pack.eResource();
//		ResourceSet resources = resource.getResourceSet();
//		for(Resource subRes : resources.getResources()){
//			TreeIterator<EObject> contents = subRes.getAllContents();
//			if(contents.hasNext()){
//				EObject obj = contents.next();
//				if(obj instanceof AadlPackage){
//					List<AnnexLibrary> agreeAnnex = AnnexUtil.getAllActualAnnexLibraries((AadlPackage) obj, AgreePackage.eINSTANCE.getAgreeContractLibrary());
//				}
//			}
//			while(contents.hasNext()){
//				EObject obj = contents.next();
//			}
//			System.out.println();
//		}
//
//		String contextProject = pack.eResource().getURI().segment(1);
//		for (IResourceDescription resourceDescription : resourceDescriptions.getAllResourceDescriptions()) {
//			for (IEObjectDescription eobjectDescription : resourceDescription.getExportedObjectsByType(Aadl2Package.eINSTANCE.getAadlPackage())) {
//				EObject description = eobjectDescription.getEObjectOrProxy();
//				System.out.println();
//			}
//		}
//	}
//
//	private Map<String, List<NamedElement>> getAllIdToElementMap(AgreeContract contract){
//
//		for(SpecStatement spec : contract.getSpecs()){
//			if (spec instanceof )
//		}
//
//		return null;
//	}

	@Check(CheckType.FAST)
	public void checkEnumStatement(EnumStatement statement) {
		String contextProject = statement.eResource().getURI().segment(1);
		Map<String, NamedID> enumMap;
		if (!enumSets.containsKey(contextProject)) {
			enumMap = new HashMap<>();
			enumSets.put(contextProject, enumMap);
		} else {
			enumMap = enumSets.get(contextProject);
		}
		for (NamedID id : statement.getEnums()) {
			NamedID otherEnum = enumMap.get(id.getName());
			if (otherEnum == null) {
				enumMap.put(id.getName(), id);
			} else if (otherEnum != id) {
				if (otherEnum.eResource() != null && otherEnum.eResource().equals(id.eResource())) {

					String message = "Multiple uses of the same enum value '" + id.getName() + "' in '"
							+ getEnumValueDefLocation(otherEnum) + "' and '" + getEnumValueDefLocation(id) + "'";
					error(otherEnum, message);
					error(id, message);
				} else {
					enumMap.put(id.getName(), id);
				}
			}
		}
		EObject container = statement.eContainer();
		while (!(container instanceof AadlPackage) && !(container instanceof ComponentClassifier)) {
			container = container.eContainer();
		}
		if (!(container instanceof AadlPackage)) {
			error(statement, "Enumerations can be defined only in AADL packages");
		}

	}

	private String getEnumValueDefLocation(NamedID id) {
		EObject container = id.eContainer();
		EnumStatement enumStatement = (EnumStatement) container;
		String enumName = enumStatement.getName();
		while (!(container instanceof AadlPackage) && !(container instanceof ComponentClassifier)) {
			container = container.eContainer();
		}
		return ((NamedElement) container).getQualifiedName() + "::" + enumName;
	}

	@Check(CheckType.FAST)
	public void checkConnectionStatement(ConnectionStatement conn) {
		Classifier container = conn.getContainingClassifier();
		if (container instanceof ComponentImplementation) {
			NamedElement aadlConn = conn.getConn();
			if (aadlConn == null) {
				return;
			}
			if (!(aadlConn instanceof Connection)) {
				error(conn, "The connection label in the connection statement is not a connection");
				return;
			}

		} else {
			error(conn, "Connection statements are allowed only in component implementations.");
		}
	}

	@Check(CheckType.FAST)
	public void checkOrderStatement(OrderStatement order) {
		Classifier container = order.getContainingClassifier();
		if (container instanceof ComponentImplementation) {
			ComponentImplementation compImpl = (ComponentImplementation) container;

			for (int index = 0; index < order.getComps().size(); ++index) {
				NamedElement comp = order.getComps().get(index);
				if (!(comp instanceof Subcomponent)
						|| !((Subcomponent) comp).getContainingComponentImpl().equals(container)) {
					error("Element '" + comp.getName() + "' is not a subcomponent of '" + container.getName() + "'",
							order, AgreePackage.Literals.ORDER_STATEMENT__COMPS, index);
				}
			}

			List<NamedElement> notPresent = new ArrayList<>();
			for (Subcomponent subcomp : compImpl.getAllSubcomponents()) {
				boolean found = false;
				for (NamedElement el : order.getComps()) {
					if (el.equals(subcomp)) {
						found = true;
						break;
					}
				}
				if (!found) {
					notPresent.add(subcomp);
				}
			}

			if (notPresent.size() != 0) {
				String delim = "";
				StringBuilder errorStr = new StringBuilder(
						"The following subcomponents are not present in the ordering: ");
				for (NamedElement subcomp : notPresent) {
					errorStr.append(delim);
					errorStr.append(subcomp.getName());
					delim = ", ";
				}
				error(order, errorStr.toString());
			}

		} else {
			error(order, "Ordering statements can appear only in component implementations");
		}

	}

	private static List<Feature> flattenFeatureGroups(List<? extends Feature> complexFeatures) {
		List<Feature> result = new ArrayList<>();
		for (Feature feature : complexFeatures) {
			if (feature instanceof FeatureGroup) {
				FeatureGroup featureGroup = (FeatureGroup) feature;
				FeatureGroupType featType = featureGroup.getFeatureGroupType();
				result.addAll(flattenFeatureGroups(featType.getOwnedFeatureGroups()));
				result.addAll(flattenFeatureGroups(featType.getOwnedDataPorts()));
				result.addAll(flattenFeatureGroups(featType.getOwnedEventDataPorts()));
				result.addAll(flattenFeatureGroups(featType.getOwnedEventPorts()));
			} else {
				result.add(feature);
			}
		}
		return result;
	}

	@Check(CheckType.FAST)
	public void checkAssign(AssignStatement assign) {
		NestedDotID dotId = assign.getId();
		NamedElement namedEl = dotId.getBase();
		Expr expr = assign.getExpr();

		if (namedEl == null || expr == null) {
			return;
		}

		ComponentImplementation compImpl = EcoreUtil2.getContainerOfType(assign, ComponentImplementation.class);

		if (compImpl == null) {
			error(assign, "Assignment statements are allowed only in component implementations");
			return;
		}

		if (dotId.getSub() != null) {
			error(dotId, "The Id on the left hand side of an assignment statement " + "must not contain a \".\"");
			return;
		}

		if (namedEl.eContainer() instanceof InputStatement) {
			error(dotId, "Assignment to agree_input variables is illegal.");
			return;
		}

		if (compImpl != null) {
			List<EObject> assignableElements = new ArrayList<>();
			List<AgreeContract> implContracts = EcoreUtil2.getAllContentsOfType(compImpl, AgreeContract.class);
			for (AgreeContract ac : implContracts) {
				assignableElements.addAll(EcoreUtil2.getAllContentsOfType(ac, EqStatement.class).stream()
						.map(eq -> eq.getLhs()).flatMap(List::stream).collect(Collectors.toList()));
			}
			ComponentType compType = compImpl.getType();
			if (compType != null) {
				List<AgreeContract> typeContracts = EcoreUtil2.getAllContentsOfType(compType, AgreeContract.class);
				for (AgreeContract ac : typeContracts) {
					assignableElements.addAll(EcoreUtil2.getAllContentsOfType(ac, EqStatement.class).stream()
							.map(eq -> eq.getLhs()).flatMap(List::stream).collect(Collectors.toList()));
				}
			}
			assignableElements.addAll(compImpl.getAllFeatures().stream()
					.map(cf -> flattenFeatureGroups(Collections.singletonList(cf))).flatMap(List::stream)
					.filter(feat -> feat instanceof EventDataPort || feat instanceof DataPort)
					.filter(feat -> DirectionType.OUT.equals(((Port) feat).getDirection()))
					.collect(Collectors.toList()));
			if (!assignableElements.contains(namedEl)) {
				error("LHS of assignment must be an AGREE 'eq' variable or an output port of this component", assign,
						AgreePackage.Literals.ASSIGN_STATEMENT__ID);
			}
		}

		AgreeType lhsType = getAgreeType(namedEl);
		AgreeType rhsType = getAgreeType(expr);

		if (!lhsType.equals(rhsType)) {
			error(assign, "The left hand side of the assignment statement is of type '" + lhsType
					+ "' but the right hand side is of type '" + rhsType + "'");
		}

		AgreeContract contract = EcoreUtil2.getContainerOfType(assign, AgreeContract.class);
		if (contract != null) {
			for (SpecStatement spec : contract.getSpecs()) {
				if (spec instanceof AssignStatement && spec != assign) {
					NamedElement otherEl = ((AssignStatement) spec).getId().getBase();
					if (otherEl.equals(namedEl)) {
						error(spec, "Mulitiple assignments to variable '" + namedEl.getName() + "'");
						error(assign, "Mulitiple assignments to variable '" + namedEl.getName() + "'");
					}
				}
			}
		}

	}

	@Check(CheckType.FAST)
	public void checkArg(Arg arg) {
		Type type = arg.getType();
		if (type instanceof PrimType) {
			PrimType primType = (PrimType) type;
			String strType = primType.getString();
			String rangeLow = primType.getRangeLow();
			String rangeHigh = primType.getRangeHigh();

			if (rangeLow != null && rangeHigh != null) {

				// this is a ranged argument. It can show up only in an equation statement
				EObject container = arg.eContainer();
				if (!(container instanceof EqStatement || container instanceof InputStatement)) {
					error(arg, "Ranged arguments can appear only in equation statements or agree_input statements");
				}

				boolean rangeLowDot = rangeLow.contains(".");
				boolean rangeHighDot = rangeHigh.contains(".");

				if (rangeLowDot != rangeHighDot) {
					error(arg, "The range intervals are of differing types");
				}

				if (strType.equals("int") && (rangeLowDot || rangeHighDot)) {
					error(arg, "Ranged variable of type 'int' contains a 'real' value in its interval");
				}

				if (strType.equals("real") && (!rangeLowDot || !rangeHighDot)) {
					error(arg, "Ranged variable of type 'real' contains an 'int' value in its interval");
				}

				float low = Float.valueOf(rangeLow);
				float high = Float.valueOf(rangeHigh);

				low *= primType.getLowNeg() == null ? 1.0 : -1.0;
				high *= primType.getHighNeg() == null ? 1.0 : -1.0;

				if (low >= high) {
					error(arg, "The low value of the interval is greater than or equal to the high end");
				}
			}

		}
	}

	@Check(CheckType.FAST)
	public void checkCalenStatement(CalenStatement calen) {
		Classifier container = calen.getContainingClassifier();
		if (!(container instanceof ComponentImplementation)) {
			error(calen, "Calendar statements can appear only in component implementations");
			return;
		}

		for (int index = 0; index < calen.getEls().size(); ++index) {
			NamedElement el = calen.getEls().get(index);
			if (!(el instanceof Subcomponent) || !((Subcomponent) el).getContainingComponentImpl().equals(container)) {
				error("Element '" + el.getName() + "' is not a subcomponent of '" + container.getName() + "'",
						calen, AgreePackage.Literals.CALEN_STATEMENT__ELS, index);
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkFloorCast(FloorCast floor) {
		if (isInLinearizationBody(floor)) {
			error(floor, "'event' expressions not allowed in linearization body expressions");
			return;
		}

		AgreeType exprType = getAgreeType(floor.getExpr());

		if (!matches(REAL, exprType)) {
			error(floor, "Argument of floor cast is of type '" + exprType.toString() + "' but must be of type 'real'");
		}
	}

	@Check(CheckType.FAST)
	public void checkRealCast(RealCast real) {
		if (isInLinearizationBody(real)) {
			error(real, "'event' expressions not allowed in linearization body expressions");
			return;
		}

		AgreeType exprType = getAgreeType(real.getExpr());

		if (!matches(INT, exprType)) {
			error(real, "Argument of real cast is of type '" + exprType.toString() + "' but must be of type 'int'");
		}
	}

	@Check(CheckType.FAST)
	public void checkEventExpr(EventExpr event) {
		if (isInLinearizationBody(event)) {
			error(event, "'event' expressions not allowed in linearization body expressions");
			return;
		}

		NestedDotID nestId = event.getId();
		NamedElement namedEl = getFinalNestId(nestId);
		if (!(namedEl instanceof EventPort || namedEl instanceof EventDataPort)) {
			error(event, "Argument of event expression must be an event port or event data port");
		}
	}

	@Check(CheckType.FAST)
	public void checkLatchedExpr(LatchedExpr latched) {

		// get container
		EObject container = latched.eContainer();
		AgreeContract contract = null;
		while (!(container instanceof ComponentClassifier)) {
			if (container instanceof AgreeContract) {
				contract = (AgreeContract) container;
			}
			container = container.eContainer();
		}

		if (container instanceof ComponentImplementation) {
			boolean foundLatchedStatement = false;
			for (SpecStatement spec : contract.getSpecs()) {
				if (spec instanceof LatchedStatement) {
					foundLatchedStatement = true;
					break;
				}
			}
			if (!foundLatchedStatement) {
				error(latched, "Latched expressions can appear only in component implementations "
						+ "that contain a latched synchrony statement");
			}
		} else {
			error(latched, "Latched expressions can appear only in component implementations");
		}

		Expr expr = latched.getExpr();
		NestedDotID nestId = null;
		if (expr instanceof NestedDotID) {
			nestId = (NestedDotID) expr;
		} else if (expr instanceof EventExpr) {
			EventExpr eventExpr = (EventExpr) expr;
			nestId = eventExpr.getId();
		}

		if (nestId != null) {
			NamedElement namedEl = getFinalNestId(nestId);
			if ((namedEl instanceof DataPort) && ((DataPort) namedEl).isIn()) {
				return;
			} else if ((namedEl instanceof EventDataPort) && ((EventDataPort) namedEl).isIn()) {
				return;
			} else {
				// check to see if it is an "agree_input"
				EObject namedElContainer = namedEl.eContainer();
				if (namedElContainer instanceof InputStatement) {
					return;
				}
			}
		}

		error(latched,
				"Latched expressions are valid only for input data ports or event expressions over input event data ports");
	}

	@Check(CheckType.FAST)
	public void checkSynchStatement(SynchStatement sync) {

		Classifier container = sync.getContainingClassifier();
		if (!(container instanceof ComponentImplementation)) {
			error(sync, "Synchrony statements can appear only in component implementations");
		}

		if (sync instanceof CalenStatement || sync instanceof MNSynchStatement || sync instanceof AsynchStatement
				|| sync instanceof LatchedStatement) {
			return;
		}

		// TODO: I'm pretty sure INT_LITs are always positive anyway.
		// So this may be redundant
		if (Integer.valueOf(sync.getVal()) < 0) {
			error(sync, "The value of synchrony statments must be positive");
		}
		String val2 = sync.getVal2();
		if (val2 != null) {
			if (Integer.valueOf(val2) <= 0) {
				error(sync, "The second value of a synchrony statment must be greater than zero");
			}
			if (Integer.valueOf(sync.getVal()) <= Integer.valueOf(val2)) {
				error(sync, "The second value of a synchrony argument must be less than the first");
			}
		}

	}

	@Check(CheckType.FAST)
	public void checkMNSynchStatement(MNSynchStatement sync) {
		ComponentImplementation compImpl = sync.getContainingComponentImpl();
		if (compImpl == null) {
			// This should already be checked by checkSynchStatement
			return;
		}
		compImpl.getAllSubcomponents();

		// this should be enforced by the parser, but we check to avoid an
		// index out of bounds exception whilst the user is editing...
		int expectedSize = sync.getMax().size();
		if (expectedSize != sync.getMin().size() || expectedSize != sync.getComp1().size()
				|| expectedSize != sync.getComp2().size()) {
			error(sync,
					"Mismatched number of subcomponents and timing ranges: " + sync.getComp1().size()
					+ " left subcomponents, " + sync.getComp2().size() + " right subcomponents, "
					+ sync.getMin().size() + " time minima, and " + sync.getMax().size() + " time maxima.");
			return;
		}

		for (int i = 0; i < expectedSize; i++) {
			NamedElement comp1 = sync.getComp1().get(i);
			NamedElement comp2 = sync.getComp2().get(i);
			String maxStr = sync.getMax().get(i);
			String minStr = sync.getMin().get(i);

			if (!(comp1 instanceof Subcomponent)
					|| !((Subcomponent) comp1).getContainingComponentImpl().equals(compImpl)) {
				error("Element '" + comp1.getName() + "' is not a subcomponent of '" + compImpl.getName() + "'",
						sync, AgreePackage.Literals.MN_SYNCH_STATEMENT__COMP1, i);
			}

			if (!(comp2 instanceof Subcomponent)
					|| !((Subcomponent) comp2).getContainingComponentImpl().equals(compImpl)) {
				error("Element '" + comp2.getName() + "' is not a subcomponent of '" + compImpl.getName() + "'",
						sync, AgreePackage.Literals.MN_SYNCH_STATEMENT__COMP2, i);
			}

			int max = Integer.valueOf(maxStr);
			int min = Integer.valueOf(minStr);

			if (max < 1 || min < 1) {
				error(sync, "Quasi-synchronous values must be greater than zero");
			}

			if (min > max) {
				error("Left hand side quasi-synchronous values must be greater than the right hand side");
			}
		}
	}

	private void getPackageDependencies(AadlPackage pkg, Set<AadlPackage> pkgs) {

		// Add the parent package if it's not there, otherwise return
		if (pkgs.contains(pkg)) {
			return;
		}
		pkgs.add(pkg);

		// Look at direct dependencies
		if (pkg.getPrivateSection() != null) {
			for (ModelUnit mu : pkg.getPrivateSection().getImportedUnits()) {
				if (mu instanceof AadlPackage) {
					getPackageDependencies((AadlPackage) mu, pkgs);
				}
			}
		}

		if (pkg.getPublicSection() != null) {
			for (ModelUnit mu : pkg.getPublicSection().getImportedUnits()) {
				if (mu instanceof AadlPackage) {
					getPackageDependencies((AadlPackage) mu, pkgs);
				}
			}
		}

	}

	private List<NamedSpecStatement> getNamedSpecStatements(AadlPackage pkg) {
		List<NamedSpecStatement> specs = new ArrayList<NamedSpecStatement>();
		for (Classifier classifier : EcoreUtil2.getAllContentsOfType(pkg, Classifier.class)) {
			for (AnnexSubclause annex : AnnexUtil.getAllAnnexSubclauses(classifier,
					AgreePackage.eINSTANCE.getAgreeContractSubclause())) {
				AgreeContract contract = (AgreeContract) ((AgreeContractSubclause) annex).getContract();
				for (SpecStatement spec : contract.getSpecs()) {
					if (spec instanceof NamedSpecStatement) {
						specs.add((NamedSpecStatement) spec);
					}
				}
			}
		}

		for (AnnexLibrary annex : AnnexUtil.getAllActualAnnexLibraries(pkg,
				AgreePackage.eINSTANCE.getAgreeContractLibrary())) {
			AgreeContract contract = (AgreeContract) ((AgreeContractLibrary) annex).getContract();
			for (SpecStatement spec : contract.getSpecs()) {
				if (spec instanceof NamedSpecStatement) {
					specs.add((NamedSpecStatement) spec);
				}
			}

		}
		return specs;
	}

	@Check(CheckType.NORMAL)
	public void checkNoDuplicateIdInSpec(AadlPackage toppkg) {

		Set<AadlPackage> pkgs = new HashSet<>();
		getPackageDependencies(toppkg, pkgs);

		HashMultimap<String, SpecStatement> multiMap = HashMultimap.create();
		for (AadlPackage pkg : pkgs) {
			List<NamedSpecStatement> specs = getNamedSpecStatements(pkg);

			// check local uniqueness
			for (NamedSpecStatement spec : specs) {

				String id = spec.getName();
//				if (spec instanceof AssumeStatement) {
//					id = ((AssumeStatement) spec).getName();
//				} else if (spec instanceof GuaranteeStatement) {
//					id = ((GuaranteeStatement) spec).getName();
//				} else if (spec instanceof AssertStatement) {
//					id = ((AssertStatement) spec).getName();
//				} else if (spec instanceof LemmaStatement) {
//					id = ((LemmaStatement) spec).getName();
//				}

				if (id != null) {
					multiMap.put(id, spec);
				}
			}
		}

		List<NamedSpecStatement> specs = getNamedSpecStatements(toppkg);
		for (NamedSpecStatement spec : specs) {

//			org.eclipse.emf.ecore.EStructuralFeature structFeat = null;
			String id = spec.getName();
//			if (spec instanceof AssumeStatement) {
//				structFeat = AgreePackage.eINSTANCE.getAssumeStatement_Name();
//				id = ((AssumeStatement) spec).getName();
//			} else if (spec instanceof GuaranteeStatement) {
//				structFeat = AgreePackage.eINSTANCE.getGuaranteeStatement_Name();
//				id = ((GuaranteeStatement) spec).getName();
//			} else if (spec instanceof AssertStatement) {
//				structFeat = AgreePackage.eINSTANCE.getAssertStatement_Name();
//				id = ((AssertStatement) spec).getName();
//			} else if (spec instanceof LemmaStatement) {
//				structFeat = AgreePackage.eINSTANCE.getLemmaStatement_Name();
//				id = ((LemmaStatement) spec).getName();
//			}

			if (multiMap.get(id).size() > 1) {
				error("Duplicate ID in AGREE claim", spec, Aadl2Package.eINSTANCE.getNamedElement_Name());
			}
		}

	}

	@Check(CheckType.FAST)
	public void checkAssume(AssumeStatement assume) {
		Classifier comp = assume.getContainingClassifier();
		if (!(comp instanceof ComponentType)) {
			error(assume, "Assume statements are allowed only in component types");
		}

		// the expression could be null if a pattern is used
		Expr expr = assume.getExpr();
		if (expr != null) {
			AgreeType exprType = getAgreeType(expr);
			if (!matches(BOOL, exprType)) {
				error(assume, "Expression for assume statement is of type '" + exprType.toString()
				+ "' but must be of type 'bool'");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkInitialStatement(InitialStatement statement) {
		Classifier comp = statement.getContainingClassifier();
		if (!(comp instanceof ComponentType)) {
			error(statement, "Initial statements are allowed only in component types");
		}

		AgreeType exprType = getAgreeType(statement.getExpr());
		if (!matches(BOOL, exprType)) {
			error(statement, "Expression for 'initially' statement is of type '" + exprType.toString()
			+ "' but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkLift(LiftStatement lift) {
		NestedDotID dotId = lift.getSubcomp();

		if (dotId.getSub() != null) {
			error(lift, "Lift statements can be applied only to direct subcomponents."
					+ "Place a lift statement in the subcomponents contract for heavy lifting");
		}

		NamedElement namedEl = dotId.getBase();

		if (namedEl != null) {
			if (!(namedEl instanceof SubcomponentImpl)) {
				error(lift, "Lift statements must apply to subcomponent implementations. '" + namedEl.getName()
				+ "' is not a subcomponent.");
			}
//            } else {
//                SubcomponentImpl subImpl = (SubcomponentImpl) namedEl;
//                if (subImpl.getComponentImplementation() == null) {
//                    error(lift, "Lift statements must apply to subcomponent implementations. '"
//                            + namedEl.getName()
//                            + "' is a subcomponent type, not a subcomponent implementation.");
//                }
//            }
		}
	}

	@Check(CheckType.FAST)
	public void checkAssert(AssertStatement asser) {
		Classifier comp = asser.getContainingClassifier();
		if (!(comp instanceof ComponentImplementation)) {
			error(asser, "Assert statements are allowed only in component implementations.");
		}

		// the expression could be null if a pattern is used
		Expr expr = asser.getExpr();
		if (expr != null) {
			AgreeType exprType = getAgreeType(expr);
			if (!matches(BOOL, exprType)) {
				error(asser, "Expression for assert statement is of type '" + exprType.toString()
				+ "' but must be of type 'bool'");
			}
		}

		warning(asser, "We highly discourage the use of assert statements. "
				+ "They can easily lead to inconsistent or unrealizable systems. "
				+ "Note that our realizability check does not verify that component "
				+ "assertions are realizable.  It is likely that you can specify the "
				+ "behavior you want by changing the subcomponent contracts or " + "by using assignment statements.");

	}

	@Check(CheckType.FAST)
	public void checkNestedDotID(NestedDotID dotId) {
		NestedDotID sub = dotId.getSub();
		if (sub != null) {
			if (sub.getBase() instanceof Property) {
				error(sub, "You cannot reference AADL properties this way." + " Use a \"Get_Property\" statement.");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkAADLEnumerator(AADLEnumerator aadlEnum) {
		NestedDotID enumType = aadlEnum.getEnumType();
		NamedElement enumTypeNamedElement = getFinalNestId(enumType);
		if (!AgreeAADLEnumerationUtils.isAADLEnumeration(enumTypeNamedElement)) {
			error(enumType, "AADL Enumerations must refer to a Data Type with \"Enum\" data representation "
					+ "property and have an \"Enumerators\' property value list.");
		} else {
			String enumVal = aadlEnum.getValue();
			List<String> enumerators = AgreeAADLEnumerationUtils
					.getEnumerators((ComponentClassifier) enumTypeNamedElement).stream()
					.map(pe -> ((org.osate.aadl2.StringLiteral) pe).getValue()).collect(Collectors.toList());
			if (!enumerators.stream().anyMatch(ev -> ev.equalsIgnoreCase(enumVal))) {
				error(aadlEnum, "AADL Enumeration " + enumTypeNamedElement.getQualifiedName()
				+ " does not have an enumeration value " + enumVal);
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkGuarantee(GuaranteeStatement guar) {
		Classifier comp = guar.getContainingClassifier();
		if (!(comp instanceof ComponentType)) {
			error(guar, "Guarantee statements are allowed only in component types");
		}

		// the expression could be null if a pattern is used
		Expr expr = guar.getExpr();
		if (expr != null) {
			AgreeType exprType = getAgreeType(expr);
			if (!matches(BOOL, exprType)) {
				error(guar, "Expression for guarantee statement is of type '" + exprType.toString()
				+ "' but must be of type 'bool'");
			}
		}
	}

	public void checkExprIsIdentifier(Expr expr) {
		if (!(expr instanceof NestedDotID)) {
			error(expr, "Patterns can contain only identifiers (not general expressions)");
		} else {
			if (((NestedDotID) expr).getSub() != null) {
				error(expr, "Patterns can contain only identifiers (not general expressions)");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkPeriodicStatement(PeriodicStatement statement) {
		Expr event = statement.getEvent();
		Expr jitter = statement.getJitter();
		Expr period = statement.getPeriod();

		checkExprIsIdentifier(event);

		AgreeType eventType = getAgreeType(event);
		if (!matches(BOOL, eventType)) {
			error(event, "Expression is of type '" + eventType + "' but must be of type 'bool'");
		}

		if (jitter != null) {
			if (!(jitter instanceof RealLitExpr || isConst(jitter))) {
				error(jitter, "The specified jitter must be a real literal");
			} else {
				Double val = getRealConstVal(jitter);
				if (val < 0) {
					error(jitter, "The specified jitter must be positive");
				}
			}
		}

		if (!(period instanceof RealLitExpr || isConst(period))) {
			error(period, "The specified period must be a real literal");
		} else {
			Double val = getRealConstVal(period);
			if (val < 0) {
				error(period, "The specified period must be positive");
			}
		}
	}

	private double getRealConstVal(Expr expr) {
		if (expr instanceof RealLitExpr) {
			RealLitExpr realLit = (RealLitExpr) expr;
			return Double.valueOf(realLit.getVal());
		} else if (expr instanceof NestedDotID) {
			NestedDotID id = (NestedDotID) expr;
			NamedElement finalId = getFinalNestId(id);
			if (finalId instanceof ConstStatement) {
				ConstStatement constState = (ConstStatement) finalId;
				return getRealConstVal(constState.getExpr());
			}
		}
		throw new IllegalArgumentException("not constant or literal value evalued");
	}

	@Check(CheckType.FAST)
	public void checkSporadicStatement(SporadicStatement statement) {
		Expr event = statement.getEvent();
		Expr jitter = statement.getJitter();
		Expr iat = statement.getIat();

		checkExprIsIdentifier(event);

		AgreeType eventType = getAgreeType(event);
		if (!matches(BOOL, eventType)) {
			error(event, "Expression is of type '" + eventType + "' but must be of type 'bool'");
		}

		if (jitter != null) {
			if (!(jitter instanceof RealLitExpr || isConst(jitter))) {
				error(jitter, "The specified jitter must be a real literal");
			} else {
				Double val = getRealConstVal(jitter);
				if (val < 0) {
					error(jitter, "The specified jitter must be positive");
				}
			}
		}

		if (!(iat instanceof RealLitExpr || isConst(iat))) {
			error(iat, "The specified interarrival time must be a real literal");
		} else {
			Double val = getRealConstVal(iat);
			if (val < 0) {
				error(iat, "The specified interarrival time must be positive");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkWhenHoldsStatement(WhenHoldsStatement when) {
		Expr condition = when.getCondition();
		Expr event = when.getEvent();
		TimeInterval condInterval = when.getConditionInterval();

		checkExprIsIdentifier(condition);
		checkExprIsIdentifier(event);

		if (condInterval != null) {
			Expr lowExpr = condInterval.getLow();
			if (lowExpr instanceof RealLitExpr) {
				RealLitExpr realExpr = (RealLitExpr) lowExpr;
				if (!realExpr.getVal().equals("0.0")) {
					error(lowExpr, "The lower bound of this interval must be zero");
				}
			}
		} else {
			error(when, "Statement most of a cause interval");
		}

		AgreeType type = getAgreeType(condition);
		if (!matches(BOOL, type)) {
			error(condition,
					"The condition of a when statement is of type '" + type + "'" + " but must be of type 'bool'");
		}
		type = getAgreeType(event);
		if (!matches(BOOL, type)) {
			error(event, "The effect of a when statement is of type '" + type + "'" + " but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkWhenOccursStatment(WhenOccursStatment when) {
		Expr condition = when.getCondition();
		Expr event = when.getEvent();
		Expr times = when.getTimes();

		checkExprIsIdentifier(condition);
		checkExprIsIdentifier(event);

		AgreeType type = getAgreeType(condition);
		if (!matches(BOOL, type)) {
			error(condition,
					"The condition of the 'when' statement is of type '" + type + "'" + " but must be of type 'bool'");
		}
		type = getAgreeType(event);
		if (!matches(BOOL, type)) {
			error(event,
					"The effect of the 'when' statement is of type '" + type + "'" + " but must be of type 'bool'");
		}
		type = getAgreeType(times);
		if (!matches(INT, type)) {
			error(event,
					"The 'times' of the 'when' statement is of type '" + type + "'" + " but must be of type 'int'");
		}

	}

	@Check(CheckType.FAST)
	public void checkWheneverOccursStatement(WheneverOccursStatement whenever) {
		Expr cause = whenever.getCause();
		Expr effect = whenever.getEffect();

		checkExprIsIdentifier(cause);
		checkExprIsIdentifier(effect);

		AgreeType type = getAgreeType(cause);
		if (!matches(BOOL, type)) {
			error(cause,
					"The cause of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
		type = getAgreeType(effect);
		if (!matches(BOOL, type)) {
			error(effect,
					"The effect of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkWheneverBecomesTrueStatement(WheneverBecomesTrueStatement whenever) {
		Expr cause = whenever.getCause();
		Expr effect = whenever.getEffect();

		checkExprIsIdentifier(cause);
		checkExprIsIdentifier(effect);

		AgreeType type = getAgreeType(cause);
		if (!matches(BOOL, type)) {
			error(cause,
					"The cause of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
		type = getAgreeType(effect);
		if (!matches(BOOL, type)) {
			error(effect,
					"The effect of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkWheneverHoldsStatement(WheneverHoldsStatement whenever) {
		Expr cause = whenever.getCause();
		Expr effect = whenever.getEffect();

		checkExprIsIdentifier(cause);
		checkExprIsIdentifier(effect);

		AgreeType type = getAgreeType(cause);
		if (!matches(BOOL, type)) {
			error(cause,
					"The cause of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
		type = getAgreeType(effect);
		if (!matches(BOOL, type)) {
			error(effect,
					"The effect of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkWheneverImpliesStatement(WheneverImpliesStatement whenever) {
		Expr cause = whenever.getCause();
		Expr lhs = whenever.getLhs();
		Expr rhs = whenever.getRhs();

		checkExprIsIdentifier(cause);
		checkExprIsIdentifier(lhs);
		checkExprIsIdentifier(rhs);

		AgreeType type = getAgreeType(cause);
		if (!matches(BOOL, type)) {
			error(cause,
					"The cause of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}

		type = getAgreeType(lhs);
		if (!matches(BOOL, type)) {
			error(lhs, "The left hand side of the 'implies' of the 'whenever' statement is of type '" + type + "' "
					+ "but must be of type 'bool'");
		}

		type = getAgreeType(rhs);
		if (!matches(BOOL, type)) {
			error(lhs, "The rhs hand side of the 'implies' of the 'whenever' statement is of type '" + type + "' "
					+ "but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkTimeInterval(TimeInterval interval) {
		Expr lower = interval.getLow();
		Expr higher = interval.getHigh();

//	    AgreeType lowerType = getAgreeType(lower);
//	    AgreeType higherType = getAgreeType(higher);

		if (!(lower instanceof RealLitExpr || isConst(lower))) {
			error(lower, "Lower interval must be a real valued literal");
		}

		if (!(higher instanceof RealLitExpr || isConst(higher))) {
			error(higher, "higher interval must be a real valued literal");
		}

	}

	protected boolean isConst(Expr expr) {
		if (expr instanceof NestedDotID) {
			NestedDotID id = (NestedDotID) expr;
			NamedElement finalId = getFinalNestId(id);
			return (finalId instanceof ConstStatement);
		} else if (expr instanceof AADLEnumerator) {
			return true;
		}
		return false;
	}

	@Check(CheckType.FAST)
	public void checkTimeRise(TimeRiseExpr timeRise) {
		NestedDotID id = timeRise.getId();
		checkTimeExpr(timeRise, id);
	}

	@Check(CheckType.FAST)
	public void checkTimeFall(TimeFallExpr timeFall) {
		NestedDotID id = timeFall.getId();
		checkTimeExpr(timeFall, id);
	}

	@Check(CheckType.FAST)
	public void checkTimeOf(TimeOfExpr timeOf) {
		NestedDotID id = timeOf.getId();
		checkTimeExpr(timeOf, id);
	}

	public void checkTimeExpr(EObject expr, NestedDotID id) {
		AgreeType type = getAgreeType(id);

		if (!matches(type, BOOL)) {
			error(expr, "Time functions can be applied only to Boolean identifiers");
		}

		if (id.getSub() != null) {
			error(expr, "Time functions can be applied only to identifiers");
		}
	}

	@Check(CheckType.FAST)
	public void checkLemma(LemmaStatement lemma) {
		Classifier comp = lemma.getContainingClassifier();
		if (!(comp instanceof ComponentImplementation)) {
			error(lemma, "Lemma statements are allowed only in component implementations and nodes");
		}

		Expr expr = lemma.getExpr();
		if (expr != null) {
			AgreeType exprType = getAgreeType(expr);
			if (!matches(BOOL, exprType)) {
				error(lemma, "Expression for lemma statement is of type '" + exprType.toString()
				+ "' but must be of type 'bool'");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkUnaryExpr(UnaryExpr unaryExpr) {
		AgreeType typeRight = getAgreeType(unaryExpr.getExpr());
		String op = unaryExpr.getOp();

		switch (op) {
		case "-":
			if (!matches(INT, typeRight) && !matches(REAL, typeRight)) {
				error(unaryExpr, "right side of unary expression '" + op + "' is of type '" + typeRight
						+ "' but must be of type 'int' or 'real'");
			}
			break;
		case "not":
			if (!matches(BOOL, typeRight)) {
				error(unaryExpr, "right side of unary expression '" + op + "' is of type '" + typeRight
						+ "' but must be of type 'bool'");
			}
			break;
		default:
			assert (false);
		}
	}

	@Check(CheckType.FAST)
	public void checkPropertyStatement(PropertyStatement propStat) {
		AnnexLibrary library = EcoreUtil2.getContainerOfType(propStat, AnnexLibrary.class);
		if (library != null) {
			error(propStat, "Property statments are allowed only in component annexes");
		}

		AgreeType exprType = getAgreeType(propStat.getExpr());
		if (!matches(BOOL, exprType)) {
			error(propStat, "Property statement '" + propStat.getName() + "' is of type '" + exprType
					+ "' but must be of type 'bool'");
		}

	}

	@Check(CheckType.FAST)
	public void checkInputStatement(InputStatement input) {
		ComponentType comp = EcoreUtil2.getContainerOfType(input, ComponentType.class);
		if (comp == null) {
			error(input, "Input statements are allowed only in component types");
		}

	}

	@Check(CheckType.FAST)
	public void checkRecordUpdateExpr(RecordUpdateExpr upExpr) {

		if (isInLinearizationBody(upExpr)) {
			error(upExpr, "Record update expressions not allowed in linearization body expression");
			return;
		}

		// The parser should enforce this. but we do this to avoid exceptions
		// running the check whilst the user is editing...
		if (upExpr.getArgs().isEmpty()) {
			error(upExpr, "Record update expression must contain at least one arg-expr pair.");
			return;
		}

		EList<NamedElement> args = upExpr.getArgs();
		EList<Expr> argExprs = upExpr.getArgExpr();

		// Figure out the type of the record being updated
		// It should be either a subcomponent of a DataImplementation or a
		// field of a record.
		// TODO: can it be a feature of a FeatureGroup?
		// Note: This message looks to be somewhat strange in that it uses
		// the arguments to the update expression to determine the type of the
		// record to be updated. However, this should be enforced by the way
		// that the scoping works.
		NamedElement arg0 = upExpr.getArgs().get(0);
		EObject arg0Container = arg0.eContainer();
		if (arg0Container instanceof DataImplementation) {
			DataImplementation dataImpl = (DataImplementation) arg0Container;
			dataImplCycleCheck(dataImpl, upExpr);
			int argIndex = 0;
			for (NamedElement arg : args) {
				if (!dataImpl.getAllSubcomponents().contains(arg)) {
					error("Argument '" + arg.getName() + "' is not a subcomponent of '" + dataImpl.getQualifiedName()
					+ "'", upExpr, AgreePackage.Literals.RECORD_UPDATE_EXPR__ARGS, argIndex);
				}
				++argIndex;
			}

		} else if (arg0Container instanceof RecordDefExpr) {
			RecordDefExpr recordDef = (RecordDefExpr) arg0Container;
			int argIndex = 0;
			for (NamedElement arg : args) {
				if (!recordDef.getArgs().contains(arg)) {
					error("Argument '" + arg.getName() + "' is not a subcomponent of '" + recordDef.getQualifiedName()
					+ "'", upExpr, AgreePackage.Literals.RECORD_UPDATE_EXPR__ARGS, argIndex);
				}
				++argIndex;
			}

		} else {
			if (!arg0.eIsProxy()) {
				error("Record to be updated must be a data implementation or AGREE record type.  " + "Found type '"
						+ getAgreeType(upExpr.getRecord()).toString() + "'.",
						upExpr, AgreePackage.Literals.RECORD_UPDATE_EXPR__RECORD, -1);
			}
			return;
		}

		// this should be enforced by the parser, but we check to avoid an
		// index out of bounds exception whilst the user is editing...
		if (args.size() != argExprs.size()) {
			error(upExpr, "Mismatched count of arguments and expressions.");
			return;
		}

		for (int i = 0; i < args.size(); i++) {
			NamedElement arg = args.get(i);
			Expr argExpr = argExprs.get(i);
			AgreeType argType = getAgreeType(arg);
			AgreeType argExprType = getAgreeType(argExpr);

			if (!matches(argType, argExprType)) {
				error(argExpr, "the update field is of type '" + argType + "', but the expression is of type '"
						+ argExprType + "'");
			}

		}

	}

	@Check(CheckType.FAST)
	public void checkRecordType(RecordType recType) {
		NestedDotID recId = recType.getRecord();
		NamedElement finalId = getFinalNestId(recId);

		if (!(finalId instanceof DataImplementation) && !(finalId instanceof RecordDefExpr)
				&& !(finalId instanceof DataType) && !(finalId instanceof EnumStatement)) {
			error(recType, "types must be record definition, data implementation, enumeration, or datatype");
		}

		if (finalId instanceof DataImplementation) {
			AgreeType agreeType = getAgreeType((DataImplementation) finalId);
			if (agreeType.equals(AgreeType.ERROR)) {
				error(recType, "Data Implementations with no subcomponents must extend"
						+ " a Base_Type that AGREE can reason about.");
				return;
			}
			if (((DataImplementation) finalId).getAllSubcomponents().size() != 0) {
				if (agreeType.equals(AgreeType.BOOL) || agreeType.equals(AgreeType.INT)
						|| agreeType.equals(AgreeType.REAL)) {
					error(finalId, "Data implementations with subcomponents cannot be"
							+ " interpreted by AGREE if they extend Base_Types");
				}
			}

			dataImplCycleCheck(recId);
			return;
		}

		if (finalId instanceof DataType) {
			AgreeType agreeType = getAgreeType((ComponentClassifier) finalId);
			if (agreeType.equals(AgreeType.ERROR)) {
				error(recType, "AADL Datatypes must extend" + " a Base_Type that AGREE can reason about.");
				return;
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkRecordExpr(RecordExpr recExpr) {

		NestedDotID recType = recExpr.getRecord();
		List<NamedElement> defArgs = getArgNames(recType);
		EList<NamedElement> exprArgs = recExpr.getArgs();
		EList<Expr> argExprs = recExpr.getArgExpr();

		NestedDotID recId = recExpr.getRecord();
		NamedElement finalId = getFinalNestId(recId);

		if (!(finalId instanceof DataImplementation) && !(finalId instanceof RecordDefExpr)) {
			error(recId, "types must be record definition or data implementation");
		}

		if (finalId instanceof DataImplementation) {
			dataImplCycleCheck(recId);
		}

		if (exprArgs.size() != defArgs.size()) {
			error(recExpr, "Incorrect number of arguments");
			return;
		}

		for (NamedElement argDefName : defArgs) {
			boolean foundArg = false;
			for (NamedElement argExprEl : exprArgs) {
				if (argExprEl.getName().equals(argDefName.getName())) {
					foundArg = true;
					break;
				}
			}
			if (!foundArg) {
				error(recExpr, "No assignment to defined variable '" + argDefName + "' in record expression.");
			}
		}

		// check typing
		Map<String, AgreeType> argNameMap = getArgNameMap(recType);
		for (int i = 0; i < recExpr.getArgs().size(); i++) {
			NamedElement actArg = recExpr.getArgs().get(i);
			String actArgName = actArg.getName();
			AgreeType defType = argNameMap.get(actArgName);
			AgreeType exprType = getAgreeType(argExprs.get(i));

			if (!matches(defType, exprType)) {
				error(recExpr, "The expression assigned to '" + actArgName + "' does not match its definition type of '"
						+ defType + "'");
			}
		}
	}

	private List<NamedElement> getArgNames(NestedDotID recId) {

		NamedElement rec = getFinalNestId(recId);
		List<NamedElement> names = new ArrayList<>();

		if (rec instanceof RecordDefExpr) {
			RecordDefExpr recDef = (RecordDefExpr) rec;
			for (Arg arg : recDef.getArgs()) {
				names.add(arg);
			}
		} else if (rec instanceof DataImplementation) {
			DataImplementation dataImpl = (DataImplementation) rec;
			for (Subcomponent sub : dataImpl.getAllSubcomponents()) {
				names.add(sub);
			}
		} else {
			error(recId, "Record type '" + rec.getName() + "' must be a feature group or a record type definition");
		}

		return names;
	}

	private Map<String, AgreeType> getArgNameMap(NestedDotID recId) {

		NamedElement rec = getFinalNestId(recId);
		Map<String, AgreeType> typeMap = new HashMap<>();

		if (rec instanceof RecordDefExpr) {
			RecordDefExpr recDef = (RecordDefExpr) rec;
			for (Arg arg : recDef.getArgs()) {
				typeMap.put(arg.getName(), getAgreeType(arg));
			}
		} else if (rec instanceof DataImplementation) {
			DataImplementation dataImpl = (DataImplementation) rec;
			for (Subcomponent sub : dataImpl.getAllSubcomponents()) {
				typeMap.put(sub.getName(), getAgreeType(sub));
			}
		} else {
			error(recId, "Record type '" + rec.getName() + "' must be a feature group or a record type definition");
		}

		return typeMap;
	}

//    private List<AgreeType> getArgTypes(NestedDotID recId){
//
//    	NamedElement rec = getFinalNestId(recId);
//    	List<AgreeType> types = new ArrayList<AgreeType>();
//
//    	if(rec instanceof RecordDefExpr){
//    		RecordDefExpr recDef = (RecordDefExpr)rec;
//    		for(Arg arg : recDef.getArgs()){
//    			types.add(getAgreeType(arg.getType()));
//    		}
//    	}else if(rec instanceof FeatureGroupType){
//    		FeatureGroupType featGroup = (FeatureGroupType)rec;
//    		for(Feature feat : featGroup.getAllFeatures()){
//    			types.add(getAgreeType(feat));
//    		}
//    	}
//
//    	return types;
//    }

	private void dataImplCycleCheck(NestedDotID dataID) {
		NamedElement finalId = getFinalNestId(dataID);
		DataImplementation dataImpl = (DataImplementation) finalId;
		dataImplCycleCheck(dataImpl, dataID);
	}

	private void dataImplCycleCheck(DataImplementation dataImpl, EObject errorSource) {
		Set<DataImplementation> dataClosure = new HashSet<>();
		Set<DataImplementation> prevClosure = null;

		for (Subcomponent sub : dataImpl.getAllSubcomponents()) {
			ComponentImplementation subImpl = sub.getComponentImplementation();
			if (subImpl != null) {
				dataClosure.add((DataImplementation) subImpl);
			}
		}

		do {
			prevClosure = new HashSet<>(dataClosure);
			for (DataImplementation subImpl : prevClosure) {
				if (subImpl == dataImpl) {
					error(errorSource, "The component implementation '" + dataImpl.getName()
					+ "' has a cyclic definition.  This cannot be reasoned about by AGREE.");
					break;
				}
				for (Subcomponent subSub : subImpl.getAllSubcomponents()) {
					ComponentImplementation subSubImpl = subSub.getComponentImplementation();
					if (subSubImpl != null) {
						dataClosure.add((DataImplementation) subSubImpl);
					}
				}

			}

		} while (!prevClosure.equals(dataClosure));

	}

	@Check(CheckType.FAST)
	public void checkRecordDefExpr(RecordDefExpr recordDef) {

		Set<RecordDefExpr> recordClosure = new HashSet<>();
		Set<RecordDefExpr> prevClosure = null;

		for (Arg arg : recordDef.getArgs()) {
			Type type = arg.getType();
			if (type instanceof RecordType) {
				NestedDotID subRec = ((RecordType) type).getRecord();
				NamedElement finalId = getFinalNestId(subRec);

//				if (!(finalId instanceof DataImplementation) && !(finalId instanceof RecordDefExpr)) {
//					error(type, "types must be record definition or data implementation");
//					return;
//				}

				if (finalId instanceof RecordDefExpr) {
					recordClosure.add((RecordDefExpr) finalId);
				} else if (finalId instanceof DataImplementation) {
					dataImplCycleCheck(subRec);
				}
			}
		}
		do {
			prevClosure = new HashSet<>(recordClosure);

			for (RecordDefExpr subRecDef : prevClosure) {

				if (subRecDef == recordDef) {
					error(recordDef,
							"The definition of type '" + recordDef.getName() + "' is involved in a cyclic definition");
					break;
				}
				for (Arg arg : subRecDef.getArgs()) {
					Type type = arg.getType();
					if (type instanceof RecordType) {
						NestedDotID subRecId = ((RecordType) type).getRecord();
						NamedElement subFinalEl = getFinalNestId(subRecId);
						if (subFinalEl instanceof RecordDefExpr) {
							recordClosure.add((RecordDefExpr) subFinalEl);
						}
					}
				}
			}
		} while (!prevClosure.equals(recordClosure));
	}

	@Check(CheckType.FAST)
	public void checkConstStatement(ConstStatement constStat) {
		Type type = constStat.getType();

		AgreeType expected = getAgreeType(type);
		AgreeType actual = getAgreeType(constStat.getExpr());

		if (!matches(expected, actual)) {
			error(constStat, "The assumed type of constant statement '" + constStat.getName() + "' is '" + expected
					+ "' but the actual type is '" + actual + "'");
		}

		// check for constant cycles
		Set<ConstStatement> constClosure = new HashSet<>();
		Set<ConstStatement> prevClosure;
		constClosure.add(constStat);

		// quick and dirty cycle check
		do {
			prevClosure = new HashSet<>(constClosure);
			for (ConstStatement constFrontElem : prevClosure) {
				List<NestedDotID> nestIds = EcoreUtil2.getAllContentsOfType(constFrontElem, NestedDotID.class);
				for (NestedDotID nestId : nestIds) {
					while (nestId != null) {
						NamedElement base = nestId.getBase();
						if (base instanceof ConstStatement) {
							ConstStatement closConst = (ConstStatement) base;
							if (closConst.equals(constStat)) {
								error(constStat, "The expression for constant statment '" + constStat.getName()
								+ "' is part of a cyclic definition");
								break;
							}
							constClosure.add(closConst);
						}
						nestId = nestId.getSub();
					}
				}
			}
		} while (!prevClosure.equals(constClosure));

		for (Expr e : EcoreUtil2.getAllContentsOfType(constStat.getExpr(), Expr.class)) {
			if (!isPossibleConstant(e)) {
				error(e, "Non-constant expression in constant declaration");
				return;
			}
		}
	}

	protected AgreeType getAgreeType(Type type) {
		String typeName = null;
		if (type instanceof PrimType) {
			typeName = ((PrimType) type).getString();
			return new AgreeType(typeName);
		} else {
			RecordType recType = (RecordType) type;
			NestedDotID recId = recType.getRecord();
			return getNestIdAsType(recId);
		}
	}

	private AgreeType getNestIdAsType(NestedDotID recId) {
		String typeName = "";
		NamedElement recEl = getFinalNestId(recId);
		EObject aadlPack = recEl.eContainer();

		while (!(aadlPack instanceof AadlPackage)) {
			aadlPack = aadlPack.eContainer();
		}

		String packName = ((AadlPackage) aadlPack).getName();

		if (recEl instanceof RecordDefExpr) {
			EObject component = recEl.eContainer();
			while (!(component instanceof ComponentClassifier) && !(component instanceof AadlPackage)) {
				component = component.eContainer();
			}

			if (component == aadlPack) {
				typeName = recEl.getName();
			} else {
				typeName = ((ComponentClassifier) component).getName() + "." + recEl.getName();
			}

		} else if (recEl instanceof DataImplementation) {
			AgreeType nativeType = getNativeType((DataImplementation) recEl);
			if (nativeType != null) {
				return nativeType;
			}
			typeName = recEl.getName();
		} else if (recEl instanceof DataType) {
			return getAgreeType((ComponentClassifier) recEl);
		} else if (recEl instanceof EnumStatement) {
			typeName = recEl.getFullName();
		}
		typeName = packName + "::" + typeName;

		return new AgreeType(typeName);
	}

	public boolean isPossibleConstant(Expr e) {
		if (e instanceof PrevExpr || e instanceof PreExpr) {
			return false;
		}

		if (e instanceof BinaryExpr) {
			if (((BinaryExpr) e).getOp().equals("->")) {
				return false;
			}
		}

		if (e instanceof NestedDotID) {
			if (EcoreUtil2.getContainerOfType(e, GetPropertyExpr.class) != null) {
				return true;
			}

			NamedElement base = getFinalNestId((NestedDotID) e);

			if (base instanceof DataImplementation || base instanceof ConstStatement || base instanceof RecordExpr
					|| base instanceof DataSubcomponent) {
				return true;
			}

			if (base instanceof DataType && e.eContainer() instanceof AADLEnumerator) {
				return true;
			}

			return false;
		}

		return true;
	}

	@Check(CheckType.FAST)
	public void checkNamedElement(NamedElement namedEl) {

		// check for namespace collision in component types of component
		// implementations
		// and for collisions between subcomponent and feature names

		EObject container = namedEl.eContainer();
		if (container == null) {
			return;
		}

		if (container instanceof RecordDefExpr || container instanceof NodeDefExpr) {
			// don't care about arguments to recDefs and nodeDefs
			// TODO: perhaps we can ignore all arguments?
			return;
		}

		while (!(container instanceof AadlPackage || container instanceof ComponentImplementation
				|| container instanceof ComponentType)) {
			container = container.eContainer();
		}

		ComponentImplementation compImpl = null;
		ComponentType type = null;
		if (container instanceof ComponentImplementation) {
			compImpl = (ComponentImplementation) container;
			type = compImpl.getType();
			checkDupNames(namedEl, type, compImpl);
		} else if (container instanceof ComponentType) {
			type = (ComponentType) container;
		}

		if (type != null) {
			for (Feature feat : type.getAllFeatures()) {
				if (namedEl.getName().equals(feat.getName())) {
					error(feat, "Element of the same name ('" + namedEl.getName() + "') in AGREE Annex in '"
							+ (compImpl == null ? type.getName() : compImpl.getName()) + "'");
					error(namedEl, "Feature of the same name ('" + namedEl.getName() + "') in component type");
				}
			}
		}

		// check name space collision with enumerated types

	}

	private void checkDupNames(NamedElement namedEl, ComponentType type, ComponentImplementation compImpl) {
		NamedElement match = matchedInAgreeAnnex(type, namedEl.getName());

		if (match != null) {
			error(match, "Element of the same name ('" + namedEl.getName() + "') in component implementation '"
					+ compImpl.getName() + "'");
			error(namedEl, "Element of the same name ('" + namedEl.getName() + "') in component type");
		}

		for (Subcomponent sub : compImpl.getAllSubcomponents()) {
			if (namedEl.getName().equals(sub.getName())) {
				error(sub, "Element of the same name ('" + namedEl.getName() + "') in AGREE Annex in '"
						+ compImpl.getName() + "'");
				error(namedEl,
						"Subcomponent of the same name ('" + namedEl.getName() + "') in component implementation");
			}
		}
	}

	private NamedElement matchedInAgreeAnnex(ComponentClassifier compClass, String name) {

		for (AnnexSubclause subClause : AnnexUtil.getAllAnnexSubclauses(compClass,
				AgreePackage.eINSTANCE.getAgreeSubclause())) {
			if (subClause instanceof AgreeSubclause) {
				AgreeContract contr = (AgreeContract) subClause.getChildren().get(0);
				for (EObject obj : contr.getChildren()) {
					if (obj instanceof NamedElement) {
						if (name.equals(((NamedElement) obj).getName())) {
							return (NamedElement) obj;
						}
					}
				}
			}
		}
		return null;
	}

	private boolean argsContainRangeValue(List<Arg> args) {
		for (Arg arg : args) {
			Type type = arg.getType();
			if (type instanceof PrimType) {
				PrimType primType = (PrimType) type;
				if (primType.getRangeHigh() != null || primType.getRangeLow() != null) {
					return true;
				}
			}
		}
		return false;
	}

	private void checkMultiAssignEq(EObject src, List<Arg> lhsArgs, Expr rhsExpr) {

		if (rhsExpr == null) {
			return;
		}

		if (lhsArgs.size() == 1) {
			// we should only need to check for cycles for single equations
			String name = lhsArgs.get(0).getName();
			ExprCycleVisitor cycleVisitor = new ExprCycleVisitor(name);
			Set<EObject> cycleObjects = cycleVisitor.doSwitch(rhsExpr);
			if (cycleObjects == null) {
				throw new IllegalArgumentException("something went wrong with the cycle checker");
			}
			for (EObject obj : cycleObjects) {
				error(obj, "Cyclic reference to variable '" + name + "'");
			}
		}

		if (argsContainRangeValue(lhsArgs)) {
			error(src, "Equation statements cannot contain a ranged value and a right hand side expression");
		}

		List<AgreeType> agreeLhsTypes = typesFromArgs(lhsArgs);
		List<AgreeType> agreeRhsTypes = new ArrayList<>();

		if (rhsExpr instanceof FnCallExpr) {
			NamedElement namedEl = getFinalNestId(((FnCallExpr) rhsExpr).getFn());
			if (namedEl instanceof NodeDefExpr) {
				NodeDefExpr nodeDef = (NodeDefExpr) namedEl;
				for (Arg var : nodeDef.getRets()) {
					agreeRhsTypes.add(getAgreeType(var.getType()));
				}
			} else if (namedEl instanceof FnDefExpr) {
				FnDefExpr fnDef = (FnDefExpr) namedEl;
				agreeRhsTypes.add(getAgreeType(fnDef.getType()));
			} else {
				return; // parse error
			}
		} else {
			agreeRhsTypes.add(getAgreeType(rhsExpr));
		}

		if (agreeLhsTypes.size() != agreeRhsTypes.size()) {
			error(src, "Equation assigns " + agreeLhsTypes.size() + " variables, but right side returns "
					+ agreeRhsTypes.size() + " values");
			return;
		}

		for (int i = 0; i < agreeLhsTypes.size(); i++) {
			AgreeType lhsType = agreeLhsTypes.get(i);
			AgreeType rhsType = agreeRhsTypes.get(i);

			if (!matches(rhsType, lhsType)) {
				error(src, "The variable '" + lhsArgs.get(i).getName() + "' on the left side of equation is of type '"
						+ lhsType + "' but must be of type '" + rhsType + "'");
			}
		}

//        // check for constant cycles
//        Set<EObject> eqClosure = new HashSet<EObject>();
//        Set<EObject> prevClosure;
//        eqClosure.add(src);
//
//        // quick and dirty cycle check
//        do {
//            prevClosure = new HashSet<EObject>(eqClosure);
//            for (EObject constFrontElem : prevClosure) {
//                List<NestedDotID> nestIds = EcoreUtil2.getAllContentsOfType(constFrontElem,
//                        NestedDotID.class);
//                for (NestedDotID nestId : nestIds) {
//                    while(nestId != null){
//                        NamedElement base = nestId.getBase();
//                        if (base instanceof Arg) {
//                            EObject container = base;
//                            while(!(container instanceof EqStatement) &&
//                                  !(container instanceof NodeEq)){
//                                container = container.eContainer();
//                            }
//                            if (lhsArgs.contains(base)) {
//                                warning(src,
//                                        "The expression for eq statment '" + base.getName()
//                                        + "' may be part of a cyclic definition");
//                                break;
//                            }
//                            eqClosure.add(container);
//                        }
//                        nestId = nestId.getSub();
//                    }
//                }
//            }
//        } while (!prevClosure.equals(eqClosure));

	}

	@Check(CheckType.FAST)
	public void checkEqStatement(EqStatement eqStat) {
		AnnexLibrary library = EcoreUtil2.getContainerOfType(eqStat, AnnexLibrary.class);
		if (library != null) {
			error(eqStat, "Equation statments are allowed only in component annexes");
		}
		checkMultiAssignEq(eqStat, eqStat.getLhs(), eqStat.getExpr());
	}

	@Check(CheckType.FAST)
	public void checkNameOverlap(AgreeContract contract) {

		Set<SynchStatement> syncs = new HashSet<>();
		Set<InitialStatement> inits = new HashSet<>();
		List<ConnectionStatement> conns = new ArrayList<>();
		// check that there are zero or more synchrony statements
		for (SpecStatement spec : contract.getSpecs()) {
			if (spec instanceof SynchStatement) {
				syncs.add((SynchStatement) spec);
			} else if (spec instanceof CalenStatement) {
				syncs.add((CalenStatement) spec);
			} else if (spec instanceof InitialStatement) {
				inits.add((InitialStatement) spec);
			} else if (spec instanceof ConnectionStatement) {
				conns.add((ConnectionStatement) spec);
			}

		}

		if (syncs.size() > 1) {
			for (SynchStatement sync : syncs) {
				error(sync, "Multiple synchrony or calender statements in a single contract");
			}
		}

		if (inits.size() > 1) {
			for (InitialStatement init : inits) {
				error(init, "Multiple initially statements in a single contract");
			}
		}

		for (int i = 0; i < conns.size(); i++) {
			ConnectionStatement connStat0 = conns.get(i);
			NamedElement conn0 = connStat0.getConn();
			for (int j = i + 1; j < conns.size(); j++) {
				ConnectionStatement connStat1 = conns.get(j);
				NamedElement conn1 = connStat1.getConn();
				if (conn0 == null || conn1 == null) {
					break;
				}
				if (conn0.equals(conn1)) {
					error(connStat0, "Multiple connection overrides for connection: '" + conn0.getName() + "'");
					error(connStat1, "Multiple connection overrides for connection: '" + conn1.getName() + "'");
				}
			}
		}

		ComponentImplementation ci = EcoreUtil2.getContainerOfType(contract, ComponentImplementation.class);
		if (ci == null) {
			return;
		}

		Set<String> parentNames = getParentNames(ci);
		for (AgreeSubclause subclause : EcoreUtil2.getAllContentsOfType(ci, AgreeSubclause.class)) {
			List<NamedElement> es = EcoreUtil2.getAllContentsOfType(subclause, NamedElement.class);
			for (NamedElement e : es) {
				if (!(e.eContainer() instanceof NodeDefExpr)) { // ignore elements in node defs
					if (parentNames.contains(e.getName())) {
						error(e, e.getName() + " already defined in component type contract");
					}
				}
			}
		}
	}

	private Set<String> getParentNames(ComponentImplementation ci) {
		Set<String> result = new HashSet<>();
		ComponentType ct = ci.getType();
		for (AgreeSubclause subclause : EcoreUtil2.getAllContentsOfType(ct, AgreeSubclause.class)) {
			List<NamedElement> es = EcoreUtil2.getAllContentsOfType(subclause, NamedElement.class);
			for (NamedElement e : es) {
				if (!(e.eContainer() instanceof NodeDefExpr || e.eContainer() instanceof LinearizationDefExpr
						|| e.eContainer() instanceof RecordDefExpr)) {
					result.add(e.getName());
				}
			}
		}
		return result;
	}

	@Check(CheckType.FAST)
	public void checkNodeEq(NodeEq nodeEq) {
		EObject container = nodeEq.eContainer();
		NodeBodyExpr containingNodeBodyExpr;
		NodeDefExpr containingNodeDefExpr;

		if (container instanceof NodeBodyExpr) {
			containingNodeBodyExpr = (NodeBodyExpr) container;
		} else {
			error(nodeEq, "Node equation must be contained in a node body.");
			return;
		}

		if (container != null) {
			container = container.eContainer();
		}
		if (container instanceof NodeDefExpr) {
			containingNodeDefExpr = (NodeDefExpr) container;
		} else {
			error(nodeEq, "Node equation must be contained in a node definition.");
			return;
		}

		List<Arg> locals = containingNodeBodyExpr.getLocs();
		List<Arg> returns = containingNodeDefExpr.getRets();
		int lhsIndex = 0;
		for (Arg lhs : nodeEq.getLhs()) {
			if (!locals.contains(lhs) && !returns.contains(lhs)) {
				error("LHS '" + lhs.getName() + "' of node equation must be a node return variable or local variable.",
						nodeEq, AgreePackage.Literals.NODE_EQ__LHS, lhsIndex);
			}
			++lhsIndex;
		}

		checkMultiAssignEq(nodeEq, nodeEq.getLhs(), nodeEq.getExpr());
	}

	@Check(CheckType.FAST)
	public void checkNodeLemma(NodeLemma nodeLemma) {
		AgreeType exprType = getAgreeType(nodeLemma.getExpr());
		if (!matches(BOOL, exprType)) {
			error(nodeLemma, "Expression for lemma statement is of type '" + exprType + "' but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkNodeStmt(NodeStmt nodeStmt) {
		List<NestedDotID> dotIds = EcoreUtil2.getAllContentsOfType(nodeStmt, NestedDotID.class);
		for (NestedDotID dotId : dotIds) {
			NamedElement id = getFinalNestId(dotId);
			if (!(id instanceof Arg) && !(id instanceof ConstStatement) && !(id instanceof NodeDefExpr)
					&& !(id instanceof FnDefExpr) && !(id instanceof DataSubcomponent) && !(id instanceof RecordType)
					&& !(id instanceof DataImplementation) && !(id instanceof RecordDefExpr)) {
				error(dotId, "Only arguments, constants, and node calls allowed within a node");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkNodeDef(NodeDefExpr nodeDefExpr) {

		if (nodeDefExpr.getNodeBody() == null) {
			return; // this will throw a parse error anyway
		}

		Map<Arg, Integer> assignMap = new HashMap<>();
		for (Arg arg : nodeDefExpr.getRets()) {
			assignMap.put(arg, 0);
		}
		for (Arg arg : nodeDefExpr.getNodeBody().getLocs()) {
			assignMap.put(arg, 0);
		}

		for (NodeStmt stmt : nodeDefExpr.getNodeBody().getStmts()) {
			if (stmt instanceof NodeEq) {
				NodeEq eq = (NodeEq) stmt;
				for (Arg arg : eq.getLhs()) {
					Integer value = assignMap.get(arg);
					if (value == null) {
						error("Equation attempting to assign '" + arg.getName()
						+ "', which is not an assignable value within the node");
						return;
					} else {
						assignMap.put(arg, value + 1);
					}
				}
			}
		}
		for (Map.Entry<Arg, Integer> elem : assignMap.entrySet()) {
			if (elem.getValue() == 0) {
				error("Variable '" + elem.getKey().getName() + "' is never assigned by an equation in node '"
						+ nodeDefExpr.getName() + "'");
				return;
			} else if (elem.getValue() > 1) {
				error("Variable '" + elem.getKey().getName() + "' is assigned multiple times in node '"
						+ nodeDefExpr.getName() + "'");
			}
		}
	}

	public static boolean isInLinearizationBody(Expr expr) {
		boolean result = false;
		EObject current = expr;
		while (current != null && current instanceof Expr) {
			EObject container = current.eContainer();
			if (container instanceof LinearizationDefExpr) {
				result = ((LinearizationDefExpr) container).getExprBody().equals(current);
			}
			current = container;
		}
		return result;
	}

	@Check(CheckType.FAST)
	public void checkLinearizationDefExpr(LinearizationDefExpr linDefExpr) {
		// Check that allowable number of formal args are defined
		if (linDefExpr.getArgs().size() != 1) {
			error(linDefExpr, "Linearization definitions are limited to functions of one variable.");
		}

		// Check that the formal args are all of real type
		for (Arg arg : linDefExpr.getArgs()) {
			AgreeType argType = getAgreeType(arg.getType());
			if (!matches(argType, REAL)) {
				error(arg, "Linearizations formal arguments must be of real type, but found type " + argType);
			}
		}

		// Check that the number of domain intervals matches the number of
		// formal arguments
		if (linDefExpr.getIntervals().size() != linDefExpr.getArgs().size()) {
			error(linDefExpr, "Number of formal variables and intervals does not match.");
		}

		// If a precision clause is present, it must be a constant expression
		// of real type
		Expr precisionExpr = linDefExpr.getPrecision();
		if (precisionExpr != null) {
			AgreeType precisionExprType = getAgreeType(precisionExpr);
			if (!matches(precisionExprType, REAL)) {
				error(precisionExpr,
						"Linearization precision must be of real type, but found type " + precisionExprType);
			}
			if (!exprIsConst(precisionExpr)) {
				error(precisionExpr, "Linearization precision must be constant expression of real type"
						+ ", found non-constant expression.");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkLinearizationInterval(LinearizationInterval linInterval) {
		final String message = "Linearization interval endpoints must be constant expressions of real type";
		Expr startExpr = linInterval.getStart();
		Expr endExpr = linInterval.getEnd();
		AgreeType startExprType = getAgreeType(startExpr);
		AgreeType endExprType = getAgreeType(endExpr);

		// The type of the interval start and end must be of real type
		if (!matches(startExprType, REAL)) {
			error(startExpr, message + ", found type " + startExprType + ".");
		}
		if (!matches(endExprType, REAL)) {
			error(endExpr, message + ", found type " + endExprType + ".");
		}

		// The interval start and end expressions must be constant
		if (!exprIsConst(startExpr)) {
			error(endExpr, message + ", found non-constant expression.");
		}
		if (!exprIsConst(startExpr)) {
			error(endExpr, message + ", found non-constant expression.");
		}
	}

	@Check(CheckType.FAST)
	public void checkThisExpr(ThisExpr thisExpr) {
		// these should appear only in Get_Property expressions

		if (!(thisExpr.eContainer() instanceof GetPropertyExpr)) {
			error(thisExpr, "'this' expressions can be used only in 'Get_Property' expressions.");
		}

	}

	private static NamedElement namedElementFromIdExpr(Expr expr) {
		if (expr instanceof NestedDotID) {
			return getFinalNestId((NestedDotID) expr);
		} else {
			assert (expr instanceof ThisExpr);
			NamedElement component = EcoreUtil2.getContainerOfType(expr, ComponentClassifier.class);

			NestedDotID nestId = ((ThisExpr) expr).getSubThis();
			while (nestId != null) {
				NamedElement base = nestId.getBase();

				if (base instanceof Subcomponent) {
					component = ((Subcomponent) base).getSubcomponentType();
					nestId = nestId.getSub();
				} else if (base instanceof FeatureGroup) {
					while (nestId.getSub() != null) {
						nestId = nestId.getSub();
						assert (nestId.getBase() instanceof Feature);
						Feature subFeat = (Feature) nestId.getBase();
						component = subFeat;
					}
					return component;
				} else {
					assert (base instanceof DataPort);
					component = base;
					return component;
				}

			}
			return component;
		}

	}

	@Check(CheckType.FAST)
	public void checkGetPropertyExpr(GetPropertyExpr getPropExpr) {
		Expr component = getPropExpr.getComponent();
		AgreeType compType = getAgreeType(component);
		// AgreeType propType = getAgreeType(propExpr.getName());
		NamedElement prop = getPropExpr.getProp();

		if (!(component instanceof NestedDotID) && !(component instanceof ThisExpr)) {
			error("Component must be qualified id or 'this' expression", getPropExpr,
					AgreePackage.Literals.GET_PROPERTY_EXPR__COMPONENT);
		}

		if (!compType.equals(new AgreeType("component"))) {
			error(getPropExpr.getComponent(), "Expected type component, but found type " + compType);
		}

		if (!(prop instanceof Property || prop instanceof PropertyConstant)) {
			error(getPropExpr.getProp(), "Expected AADL property or property constant");
		}

		if (prop instanceof Property) {
			NamedElement element = namedElementFromIdExpr(component);
			final boolean applies = element.acceptsProperty((Property) prop);
			if (!applies) {
				error("Property " + ((Property) prop).getQualifiedName() + " does not apply to "
						+ element.getQualifiedName() + ".", getPropExpr,
						AgreePackage.Literals.GET_PROPERTY_EXPR__PROP);
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkPrevExpr(PrevExpr prevExpr) {
		AgreeType delayType = getAgreeType(prevExpr.getDelay());
		AgreeType initType = getAgreeType(prevExpr.getInit());

		if (!matches(initType, delayType)) {
			error(prevExpr, "The first and second arguments of the 'prev' function are of non-matching types '"
					+ delayType + "' and '" + initType + "'");
		}

		if (isInLinearizationBody(prevExpr)) {
			error(prevExpr, "'prev' expressions are not allowed in linearization body expressions.");
		}
	}

	public void checkInputsVsActuals(FnCallExpr fnCall) {
		NestedDotID dotId = fnCall.getFn();

		// if the id has a 'tag' then it is using a resrved variable
		String tag = getNestedDotIDTag(dotId);
		if (tag != null) {
			error(fnCall, "Use of reserved variable tag: '" + tag + " does not make sense"
					+ " in the context of a node call");
		}

		NamedElement namedEl = getFinalNestId(dotId);

		if (!(namedEl instanceof CallDef)) {
			// this error will be caught elsewhere
			return;
		}

		CallDef callDef = (CallDef) namedEl;

		List<AgreeType> inDefTypes;
		String callName;

		// extract in/out arguments
		if (callDef instanceof FnDefExpr) {
			FnDefExpr fnDef = (FnDefExpr) callDef;
			inDefTypes = typesFromArgs(fnDef.getArgs());
			callName = fnDef.getName();
		} else if (callDef instanceof NodeDefExpr) {
			NodeDefExpr nodeDef = (NodeDefExpr) callDef;
			inDefTypes = typesFromArgs(nodeDef.getArgs());
			callName = nodeDef.getName();
		} else if (callDef instanceof LinearizationDefExpr) {
			LinearizationDefExpr linDef = (LinearizationDefExpr) callDef;
			inDefTypes = typesFromArgs(linDef.getArgs());
			callName = linDef.getName();
		} else if (callDef instanceof LibraryFnDefExpr) {
			LibraryFnDefExpr nativeDef = (LibraryFnDefExpr) callDef;
			inDefTypes = typesFromArgs(nativeDef.getArgs());
			callName = nativeDef.getName();
		} else {
			error(fnCall, "Node, function or linearization definition name expected.");
			return;
		}

		// extract args
		List<AgreeType> argCallTypes = getAgreeTypes(fnCall.getArgs());

		if (inDefTypes.size() != argCallTypes.size()) {
			error(fnCall, "Function definition '" + callName + "' requires " + inDefTypes.size()
			+ " arguments, but this function call provides " + argCallTypes.size() + " arguments");
			return;
		}

		for (int i = 0; i < inDefTypes.size(); i++) {
			AgreeType callType = argCallTypes.get(i);
			AgreeType defType = inDefTypes.get(i);

			if (!matches(defType, callType)) {
				error(fnCall, "Argument " + i + " of function call '" + callName + "' is of type '" + callType
						+ "' but must be of type '" + defType + "'");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkFnCallExpr(FnCallExpr fnCall) {
		NamedElement fn = getFinalNestId(fnCall.getFn());
		if (isInLinearizationBody(fnCall)) {
			if (fn instanceof NodeDefExpr) {
				error(fnCall, "Node definitions cannot be applied in a linearization definition");
			}
		} else {
			if (fn instanceof LibraryFnDefExpr) {
				if (fn.getElementRoot().getName().equalsIgnoreCase("dreal")) {
					warning(fnCall, "dReal library functions require the use of the dReal solver");
				} else {
					error(fnCall, "Library functions cannot be called from the logic");
				}
			}
		}
		checkInputsVsActuals(fnCall);
	}

	@Check(CheckType.FAST)
	public void checkFnDefExpr(FnDefExpr fnDef) {

		// verify typing
		AgreeType fnType = getAgreeType(fnDef.getType());
		if (fnType == null) {
			return; // this error will be caught in parsing
		}
		AgreeType exprType = getAgreeType(fnDef.getExpr());
		if (!exprType.equals(fnType)) {
			error(fnDef, "Function '" + fnDef.getName() + "' is of type '" + fnType.toString()
			+ "' but its expression is of type '" + exprType + "'");
		}

	}

	@Check(CheckType.FAST)
	public void checkCallDef(CallDef callDef) {

		// don't check recursive calls of functions that have
		// already been walked over
		if (checkedRecCalls.contains(callDef)) {
			return;
		}

		FnCallRecursionHelper recHelp = new FnCallRecursionHelper();
		recHelp.doSwitch(callDef);

		for (LinkedList<CallDef> loop : recHelp.loops) {
			StringBuilder loopStr = new StringBuilder();
			String sep = "";
			for (CallDef tempCallDef : loop) {
				checkedRecCalls.add(tempCallDef);
				String callName = tempCallDef.getName();
				loopStr.append(sep);
				loopStr.append(callName);
				sep = " -> ";
			}

			error(callDef, "There exists a recursive dependency between the " + "following node or function calls : "
					+ loopStr);

		}
	}

	@Check(CheckType.FAST)
	public void checkIfThenElseExpr(IfThenElseExpr expr) {
		if (isInLinearizationBody(expr)) {
			error(expr, "If-then-else expressions not allowed in linearization body expressions");
			return;
		}

		AgreeType condType = getAgreeType(expr.getA());
		AgreeType thenType = getAgreeType(expr.getB());
		AgreeType elseType = getAgreeType(expr.getC());

		if (!matches(BOOL, condType)) {
			error(expr, "The condition of the if statement is of type '" + condType + "' but must be of type 'bool'");
		}

		if (!matches(elseType, thenType)) {
			error(expr, "The 'then' and 'else' expressions are of non-matching types '" + thenType + "' and '"
					+ elseType + "'");
		}
	}

	@Check(CheckType.FAST)
	public void checkPreExpr(PreExpr expr) {
		if (isInLinearizationBody(expr)) {
			error(expr, "'pre' expressions not allowed in linearization body expressions");
		}
	}

	private AgreeType getAgreeType(IfThenElseExpr expr) {
		return getAgreeType(expr.getB());
	}

	/*
	 * @Check(CheckType.FAST)
	 * public void checkUnaryNonLinearExpr(UnaryNonLinearExpr expr) {
	 * AgreeType typeSub = getAgreeType(expr.getExpr());
	 * String op = expr.getOp();
	 * warning(expr, "Use of trigonometric function: '" + op
	 * + "'.  Trigonometric expressions are allowed only with dReal."
	 * + " Scalability is as yet unknown.");
	 * if (!matches(REAL, typeSub)) {
	 * error(expr, "argument to trigonometric function '" + op + "' is of type '" + typeSub.toString()
	 * + "' but must be of " + "type 'real'");
	 * }
	 * }
	 *
	 * @Check(CheckType.FAST)
	 * public void checkBinaryNonLinearExpr(BinaryNonLinearExpr expr) {
	 * AgreeType typeLeft = getAgreeType(expr.getLeft());
	 * AgreeType typeRight = getAgreeType(expr.getRight());
	 * String op = expr.getOp();
	 * warning(expr, "Use of trigonometric function: '" + op
	 * + "'.  Trigonometric expressions are allowed only with dReal."
	 * + " Scalability is as yet unknown.");
	 * if (!matches(REAL, typeLeft)) {
	 * error(expr, "argument to trigonometric function '" + op + "' is of type '" + typeLeft.toString()
	 * + "' but must be of " + "type 'real'");
	 * }
	 * if (!matches(REAL, typeRight)) {
	 * error(expr, "argument to trigonometric function '" + op + "' is of type '" + typeRight.toString()
	 * + "' but must be of " + "type 'real'");
	 * }
	 * }
	 */
	@Check(CheckType.FAST)
	public void checkBinaryExpr(BinaryExpr binExpr) {
		AgreeType typeLeft = getAgreeType(binExpr.getLeft());
		AgreeType typeRight = getAgreeType(binExpr.getRight());
		String op = binExpr.getOp();
		Expr rightSide = binExpr.getRight();
		Expr leftSide = binExpr.getLeft();
		boolean isInLinearizationBodyExpr = isInLinearizationBody(binExpr);

		boolean rightSideConst = exprIsConst(rightSide);
		boolean leftSideConst = exprIsConst(leftSide);

		switch (op) {
		case "->":
			if (isInLinearizationBodyExpr) {
				error(binExpr, "Arrow '->' expressions are not allowed in linearization body expressions.");
			} else {
				if (!matches(typeRight, typeLeft)) {
					error(binExpr, "left and right sides of binary expression '" + op + "' are of type '" + typeLeft
							+ "' and '" + typeRight + "', but must be of the same type");
				}
			}
			return;

		case "=>":
		case "<=>":
		case "and":
		case "or":
			if (isInLinearizationBodyExpr) {
				error(binExpr,
						"Logical expressions (like '" + op + "') are not allowed in linearization body expressions.");
			} else {
				if (!matches(BOOL, typeLeft)) {
					error(binExpr, "left side of binary expression '" + op + "' is of type '" + typeLeft.toString()
					+ "' but must be of " + "type 'bool'");
				}
				if (!matches(BOOL, typeRight)) {
					error(binExpr, "right side of binary expression '" + op + "' is of type '" + typeRight.toString()
					+ "' but must be of" + " type 'bool'");
				}
			}
			return;

		case "=":
		case "<>":
		case "!=":
			if (isInLinearizationBodyExpr) {
				error(binExpr, "Logical comparison expressions (like '" + op
						+ "') are not allowed in linearization body expressions.");
			} else {
				if (!matches(typeRight, typeLeft)) {
					error(binExpr, "left and right sides of binary expression '" + op + "' are of type '" + typeLeft
							+ "' and '" + typeRight + "', but must be of the same type");
				}
			}
			return;

		case "<":
		case "<=":
		case ">":
		case ">=":
			if (isInLinearizationBodyExpr) {
				error(binExpr, "Comparison expressions (like '" + op
						+ "') are not allowed in linearization body expressions.");
			} else {
				if (!matches(typeRight, typeLeft)) {
					error(binExpr, "left and right sides of binary expression '" + op + "' are of type '" + typeLeft
							+ "' and '" + typeRight + "', but must be of the same type");
				}
				if (!matches(INT, typeLeft) && !matches(REAL, typeLeft)) {
					error(binExpr, "left side of binary expression '" + op + "' is of type '" + typeLeft
							+ "' but must be of type" + "'int' or 'real'");
				}
				if (!matches(INT, typeRight) && !matches(REAL, typeRight)) {
					error(binExpr, "right side of binary expression '" + op + "' is of type '" + typeRight
							+ "' but must be of type" + "'int' or 'real'");
				}
			}
			return;

		case "+":
		case "-":
		case "*":
			if (!matches(typeRight, typeLeft)) {
				error(binExpr, "left and right sides of binary expression '" + op + "' are of type '" + typeLeft
						+ "' and '" + typeRight + "', but must be of the same type");
			}
			if (!matches(INT, typeLeft) && !matches(REAL, typeLeft)) {
				error(binExpr, "left side of binary expression '" + op + "' is of type '" + typeLeft
						+ "' but must be of type" + "'int' or 'real'");
			}
			if (!matches(INT, typeRight) && !matches(REAL, typeRight)) {
				error(binExpr, "right side of binary expression '" + op + "' is of type '" + typeRight
						+ "' but must be of type" + "'int' or 'real'");
			}

			if (op.equals("*") && !isInLinearizationBodyExpr) {
				if (!rightSideConst && !leftSideConst) {
					warning(binExpr,
							"neither the right nor the left side of binary expression '" + op
							+ "' is constant'.  Non-linear expressions are allowed only with z3 and dReal."
							+ " With z3 they are not recomended.");
				}
			}
			return;

		case "mod":
		case "div":
			if (isInLinearizationBodyExpr) {
				error(binExpr, "Integer operation expressions (like '" + op
						+ "') are not allowed in linearization body expressions.");
			} else {
				if (!matches(INT, typeLeft)) {
					error(binExpr, "left side of binary expression '" + op + "' is of type '" + typeLeft
							+ "' but must be of type 'int'");
				}
				if (!matches(INT, typeRight)) {
					error(binExpr, "right side of binary expression '" + op + "' is of type '" + typeRight
							+ "' but must be of type 'int'");
				}
				if (!rightSideConst) {
					warning(binExpr,
							"right side of binary expression '" + op + "' is not constant."
									+ " Non-linear expressions are allowed only with z3."
									+ " Even with z3 they are not recomended...");
				}
			}
			return;

		case "/":
			if (!matches(REAL, typeLeft)) {
				error(binExpr, "left side of binary expression '" + op + "' is of type '" + typeLeft
						+ "' but must be of type 'real'");
			}
			if (!matches(REAL, typeRight)) {
				error(binExpr, "right side of binary expression '" + op + "' is of type '" + typeRight
						+ "' but must be of type 'real'");
			}

			if (!rightSideConst && !isInLinearizationBodyExpr) {
				warning(binExpr,
						"right side of binary expression '" + op + "' is not constant."
								+ " Non-linear expressions are allowed only with z3."
								+ " Even with z3 they are not recomended...");
			}

			return;

		default:
			assert (false);
		}
	}

	public static boolean exprIsConst(Expr expr) {
		if (expr instanceof NestedDotID) {
			NamedElement finalId = getFinalNestId((NestedDotID) expr);
			if (finalId instanceof ConstStatement) {
				return true;
			}
		} else if (expr instanceof RealLitExpr || expr instanceof IntLitExpr || expr instanceof BoolLitExpr) {
			return true;
		} else if (expr instanceof BinaryExpr) {
			BinaryExpr binExpr = (BinaryExpr) expr;
			return exprIsConst(binExpr.getLeft()) && exprIsConst(binExpr.getRight());
		} else if (expr instanceof UnaryExpr) {
			UnaryExpr unExpr = (UnaryExpr) expr;
			return exprIsConst(unExpr.getExpr());
		}
		return false;
	}

//	// TODO: Don't we need more validation here? What if the Id of the IdExpr
//	private Boolean hasCallDefParent(Element e) {
//		while (e != null) {
//			if (e instanceof CallDef) {
//				return true;
//			}
//			e = e.getOwner();
//		}
//		return false;
//	}
//
//	private void checkScope(Expr expr, NamedElement id) {
//		if (hasCallDefParent(expr)) {
//			if (!hasCallDefParent(id) && !(id instanceof ConstStatement)) {
//				error("Unknown identifier Id: '" + id
//						+ "' (Note that nodes can refer only to inputs, outputs, and local variables and global constants).");
//			}
//		}
//	}

	public static NamedElement getFinalNestId(NestedDotID dotId) {
		while (dotId.getSub() != null) {
			dotId = dotId.getSub();
		}

		return dotId.getBase();
	}

	public String getNestedDotIDTag(NestedDotID dotId) {
		while (dotId.getSub() != null) {
			dotId = dotId.getSub();
		}

		return dotId.getTag();
	}

	public AgreeType getAgreeType(Arg arg) {
		return getAgreeType(arg.getType());
	}

	private AgreeType getAgreeType(UnaryExpr unaryExpr) {
		return getAgreeType(unaryExpr.getExpr());
	}

	private AgreeType getAgreeType(NestedDotID nestDotIdExpr) {

		String tag = getNestedDotIDTag(nestDotIdExpr);

		if (tag != null) {
			switch (tag) {
			case "_CLK":
			case "_INSERT":
			case "_REMOVE":
				return BOOL;
			case "_COUNT":
				return INT;
			default:
				return ERROR;
			}
		}

		return getAgreeType(getFinalNestId(nestDotIdExpr));
	}

	protected AgreeType getAgreeType(NamedElement namedEl) {
		if (namedEl instanceof DataSubcomponent) {
			// this is for checking "Base_Types::Boolean" etc...
			ComponentClassifier compClass = ((DataSubcomponent) namedEl).getAllClassifier();
			if (compClass instanceof DataImplementation) {
				return getAgreeType((DataImplementation) compClass);
			}
			return getAgreeType(compClass);
		} else if (namedEl instanceof Arg) {
			return getAgreeType((Arg) namedEl);
		} else if (namedEl instanceof ClassifierType || namedEl instanceof Subcomponent) {
			return new AgreeType("component");
		} else if (namedEl instanceof PropertyStatement) {
			return getAgreeType((PropertyStatement) namedEl);
		} else if (namedEl instanceof ConstStatement) {
			return getAgreeType((ConstStatement) namedEl);
		} else if (namedEl instanceof EqStatement) {
			return getAgreeType(namedEl);
		} else if (namedEl instanceof DataPort) {
			return getAgreeType(((DataPort) namedEl).getDataFeatureClassifier());
		} else if (namedEl instanceof EventDataPort) {
			return getAgreeType(((EventDataPort) namedEl).getDataFeatureClassifier());
		} else if (namedEl instanceof DataAccess) {
			return getAgreeType((NamedElement) ((DataAccess) namedEl).getFeatureClassifier());
		} else if (namedEl instanceof DataType) {
			return getAgreeType((ComponentClassifier) namedEl);
		} else if (namedEl instanceof DataImplementation) {
			return getAgreeType((DataImplementation) namedEl);
		} else if (namedEl instanceof NamedID) {
			return getAgreeType((NamedID) namedEl);
		}

		return ERROR;
	}

	private AgreeType getAgreeType(NamedID id) {
		EObject container = id.eContainer();
		if (!(container instanceof EnumStatement)) {
			throw new IllegalArgumentException("NamedIDs allowed only in enum statements.");
		}
		return getAgreeType((EnumStatement) container);
	}

	private AgreeType getAgreeType(EnumStatement statement) {
		String name = statement.getName();
		EObject container = statement.eContainer();

		while (!(container instanceof AadlPackage)) {
			if (container instanceof ComponentClassifier) {
				name = ((ComponentClassifier) container).getName() + "::" + name;
			}
			container = container.eContainer();
		}
		name = ((AadlPackage) container).getName() + "::" + name;
		return new AgreeType(name);
	}

	private AgreeType getAgreeType(DataImplementation dataImpl) {

		AgreeType nativeType = getNativeType(dataImpl);
		if (nativeType != null) {
			return nativeType;
		}

		AadlPackage aadlPack = (AadlPackage) dataImpl.eContainer().eContainer();

		String typeStr = aadlPack.getName() + "::" + dataImpl.getName();

		return new AgreeType(typeStr);
	}

	private AgreeType getNativeType(DataImplementation dataImpl) {
		EList<Subcomponent> subComps = dataImpl.getAllSubcomponents();
		// if there are no subcomponents, use the component type
		if (subComps.size() == 0) {
			return getAgreeType((ComponentClassifier) dataImpl.getType());
		}
		return null;
	}

	private AgreeType getAgreeType(ComponentClassifier dataClass) {

		while (dataClass != null) {
			switch (dataClass.getQualifiedName()) {
			case "Base_Types::Boolean":
				return BOOL;
			case "Base_Types::Integer":
				return INT;
			case "Base_Types::Float":
				return REAL;
			}

			boolean is_aadl_enum = AgreeAADLEnumerationUtils.isAADLEnumeration(dataClass);
			if (is_aadl_enum) {
				String name = dataClass.getName();
				EObject container = dataClass.eContainer();

				while (!(container instanceof AadlPackage)) {
					if (container instanceof ComponentClassifier) {
						name = ((ComponentClassifier) container).getName() + "::" + name;
					}
					container = container.eContainer();
				}
				name = ((AadlPackage) container).getName() + "::" + name;
				return new AgreeType(name);
			}

			DataType dataType = (DataType) dataClass;
			dataClass = dataType.getExtended();
		}

		return ERROR;
	}

	private AgreeType getAgreeType(ComponentType compType) {

		while (compType.getExtended() != null) {
			compType = compType.getExtended();
		}

		String qualName = compType.getQualifiedName();
		switch (qualName) {
		case "Base_Types::Boolean":
			return BOOL;
		case "Base_Types::Integer":
			return INT;
		case "Base_Types::Float":
			return REAL;
		}

		return new AgreeType(qualName);

	}

	private AgreeType getAgreeType(DataSubcomponentType data) {
		if (data instanceof DataType) {
			ComponentType compType = ((DataType) data).getExtended();
			if (compType != null && !AgreeAADLEnumerationUtils.isAADLEnumeration(data)) {
				return getAgreeType(compType);
			}
		}
		String qualName = data.getQualifiedName();
		if (qualName == null) {
			return ERROR;
		}
		switch (qualName) {
		case "Base_Types::Boolean":
			return BOOL;
		case "Base_Types::Integer":
			return INT;
		case "Base_Types::Float":
			return REAL;
		}
		return new AgreeType(qualName);
	}

	private AgreeType getAgreeType(PropertyStatement propStat) {
		return getAgreeType(propStat.getExpr());
	}

	private AgreeType getAgreeType(ConstStatement constStat) {
		return getAgreeType(constStat.getType());
	}

	private AgreeType getAgreeType(GetPropertyExpr getPropExpr) {
		NamedElement namedEl = getPropExpr.getProp();
		if ((namedEl instanceof Property) || namedEl instanceof PropertyConstant) {
			PropertyType propType;
			if (namedEl instanceof Property) {
				propType = ((Property) namedEl).getPropertyType();
			} else {
				propType = ((PropertyConstant) namedEl).getPropertyType();
			}

			if (propType instanceof AadlBoolean) {
				return BOOL;
			} else if (propType instanceof AadlString || propType instanceof EnumerationType) {
				return new AgreeType("string");
			} else if (propType instanceof AadlInteger) {
				return INT;
			} else if (propType instanceof AadlReal) {
				return REAL;
			} else if (propType instanceof ClassifierType) {
				return new AgreeType("component");
			}
		}
		return ERROR;
	}

	private AgreeType getAgreeType(PrevExpr prevExpr) {
		return getAgreeType(prevExpr.getDelay());
	}

	private List<AgreeType> getAgreeTypes(List<? extends Expr> exprs) {
		ArrayList<AgreeType> list = new ArrayList<>();
		for (Expr expr : exprs) {
			list.add(getAgreeType(expr));
		}
		return list;
	}

	public List<AgreeType> typesFromArgs(List<Arg> args) {
		ArrayList<AgreeType> list = new ArrayList<>();
		for (Arg arg : args) {
			list.add(getAgreeType(arg));
		}
		return list;
	}

	private AgreeType getAgreeType(FnCallExpr fnCall) {
		// TODO: Examine type system in more detail
		// TODO: Fix to make support type lists.

		NestedDotID dotId = fnCall.getFn();
		NamedElement namedEl = getFinalNestId(dotId);

		if (isInLinearizationBody(fnCall)) {
			// extract in/out arguments
			if (namedEl instanceof FnDefExpr || namedEl instanceof NodeDefExpr) {
				error(fnCall, "Calls to AGREE nodes and functions not allowed in linearization bodies");
				return ERROR;
			} else if (namedEl instanceof LinearizationDefExpr) {
				return REAL;
			} else if (namedEl instanceof LibraryFnDefExpr) {
				LibraryFnDefExpr fnDef = (LibraryFnDefExpr) namedEl;
				return getAgreeType(fnDef.getType());
			} else {
				error(fnCall, "Node, function or linearization definition name expected.");
				return ERROR;
			}

		} else {
			// extract in/out arguments
			if (namedEl instanceof FnDefExpr) {
				FnDefExpr fnDef = (FnDefExpr) namedEl;
				return getAgreeType(fnDef.getType());
			} else if (namedEl instanceof NodeDefExpr) {
				NodeDefExpr nodeDef = (NodeDefExpr) namedEl;
				List<AgreeType> outDefTypes = typesFromArgs(nodeDef.getRets());
				if (outDefTypes.size() == 1) {
					return outDefTypes.get(0);
				} else {
					error(fnCall, "Nodes embedded in expressions must have exactly one return value." + "  Node "
							+ nodeDef.getName() + " contains " + outDefTypes.size() + " return values");
					return ERROR;
				}
			} else if (namedEl instanceof LinearizationDefExpr) {
				return REAL;
			} else if (namedEl instanceof LibraryFnDefExpr) {
				LibraryFnDefExpr fnDef = (LibraryFnDefExpr) namedEl;
				return getAgreeType(fnDef.getType());
			} else {
				error(fnCall, "Node, function or linearization definition name expected.");
				return ERROR;
			}
		}
	}

	private AgreeType getAgreeType(BinaryExpr binExpr) {
		AgreeType typeLeft = getAgreeType(binExpr.getLeft());
		String op = binExpr.getOp();

		switch (op) {
		case "->":
			return typeLeft;
		case "=>":
		case "<=>":
		case "and":
		case "or":
			return BOOL;
		case "<>":
		case "!=":
			return BOOL;
		case "<":
		case "<=":
		case ">":
		case ">=":
		case "=":
			return BOOL;
		case "+":
		case "-":
		case "*":
		case "/":
		case "mod":
		case "div":
		case "^":
			return typeLeft;
		}

		return ERROR;
	}

	protected AgreeType getAgreeType(Expr expr) {
		if (expr instanceof BinaryExpr) {
			return getAgreeType((BinaryExpr) expr);
		} else if (expr instanceof FnCallExpr) {
			return getAgreeType((FnCallExpr) expr);
		} else if (expr instanceof IfThenElseExpr) {
			return getAgreeType((IfThenElseExpr) expr);
		} else if (expr instanceof PrevExpr) {
			return getAgreeType((PrevExpr) expr);
		} else if (expr instanceof GetPropertyExpr) {
			return getAgreeType((GetPropertyExpr) expr);
		} else if (expr instanceof NestedDotID) {
			return getAgreeType((NestedDotID) expr);
		} else if (expr instanceof UnaryExpr) {
			return getAgreeType((UnaryExpr) expr);
		} else if (expr instanceof IntLitExpr) {
			return INT;
		} else if (expr instanceof RealLitExpr) {
			return REAL;
		} else if (expr instanceof BoolLitExpr) {
			return BOOL;
		} else if (expr instanceof ThisExpr) {
			return new AgreeType("component");
		} else if (expr instanceof PreExpr) {
			return getAgreeType(((PreExpr) expr).getExpr());
		} else if (expr instanceof RecordExpr) {
			return getAgreeType((RecordExpr) expr);
		} else if (expr instanceof RecordUpdateExpr) {
			return getAgreeType((RecordUpdateExpr) expr);
		} else if (expr instanceof FloorCast) {
			return INT;
		} else if (expr instanceof RealCast) {
			return REAL;
		} else if (expr instanceof EventExpr) {
			return BOOL;
		} else if (expr instanceof TimeExpr) {
			return REAL;
		} else if (expr instanceof AADLEnumerator) {
			return getAgreeType((AADLEnumerator) expr);
		} else if (expr instanceof LatchedExpr) {
			return getAgreeType(((LatchedExpr) expr).getExpr());
		} else if (expr instanceof TimeOfExpr || expr instanceof TimeRiseExpr || expr instanceof TimeFallExpr) {
			return REAL;
		} /*
		 * else if (expr instanceof UnaryNonLinearExpr ||
		 * expr instanceof BinaryNonLinearExpr) {
		 * return REAL;
		 * }
		 */

		return ERROR;
	}

	private AgreeType getAgreeType(AADLEnumerator enumExpr) {
		return getAgreeType(enumExpr.getEnumType());
	}

	private AgreeType getAgreeType(RecordUpdateExpr upExpr) {
		return getAgreeType(upExpr.getRecord());
	}

	private AgreeType getAgreeType(RecordExpr recExpr) {
		return getNestIdAsType(recExpr.getRecord());
	}

	public static boolean matches(AgreeType expected, AgreeType actual) {
		if (expected.equals(ERROR) || actual.equals(ERROR)) {
			return false;
		} else if (integerMatch(expected, actual)) {
			return true;
		} else if (floatingPointMatch(expected, actual)) {
			return true;
		}
		return expected.equals(actual);
	}

	private static boolean floatingPointMatch(AgreeType expected, AgreeType actual) {
		if (expected.toString().equals("real") && actual.toString().startsWith("Base_Types::Float")) {
			return true;
		}
		if (actual.toString().equals("real") && expected.toString().startsWith("Base_Types::Float")) {
			return true;
		}
		return false;
	}

	private static boolean integerMatch(AgreeType expected, AgreeType actual) {
		if (expected.toString().equals("int") && actual.toString().startsWith("Base_Types::Integer")) {
			return true;
		}
		if (actual.toString().equals("int") && expected.toString().startsWith("Base_Types::Integer")) {
			return true;
		}
		return false;
	}
}
